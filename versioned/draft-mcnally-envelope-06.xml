<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
]>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
<!-- generated by https://github.com/cabo/kramdown-rfc version 1.6.39 (Ruby 2.6.10) -->
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" ipr="trust200902" docName="draft-mcnally-envelope-06" category="exp" submissionType="IETF" tocInclude="true" sortRefs="true" symRefs="true" version="3">
  <!-- xml2rfc v2v3 conversion 3.18.0 -->
  <front>
    <title abbrev="Envelope">The Gordian Envelope Structured Data Format</title>
    <seriesInfo name="Internet-Draft" value="draft-mcnally-envelope-06"/>
    <author initials="W." surname="McNally" fullname="Wolf McNally">
      <organization>Blockchain Commons</organization>
      <address>
        <email>wolf@wolfmcnally.com</email>
      </address>
    </author>
    <author initials="C." surname="Allen" fullname="Christopher Allen">
      <organization>Blockchain Commons</organization>
      <address>
        <email>christophera@lifewithalacrity.com</email>
      </address>
    </author>
    <date year="2024" month="February" day="18"/>
    <area>Applications and Real-Time</area>
    <workgroup>Network Working Group</workgroup>
    <keyword>Internet-Draft</keyword>
    <abstract>
      <?line 60?>

<t>Gordian Envelope specifies a structured format for hierarchical binary data focused on the ability to transmit it in a privacy-focused way, offering support for privacy as described in RFC 6973 and human rights as described in RFC 8280. Envelopes are designed to facilitate "smart documents" and have a number of unique features including: easy representation of a variety of semantic structures, a built-in Merkle-like digest tree, deterministic representation using CBOR, and the ability for the holder of a document to selectively elide specific parts of a document without invalidating the digest tree structure. This document specifies the base Envelope format, which is designed to be extensible.</t>
    </abstract>
    <note removeInRFC="true">
      <name>Discussion Venues</name>
      <t>Source for this draft and an issue tracker can be found at
    <eref target="https://github.com/BlockchainCommons/envelope-internet-draft"/>.</t>
    </note>
  </front>
  <middle>
    <?line 64?>

<section anchor="introduction">
      <name>Introduction</name>
      <t>Gordian Envelope was designed with two key goals in mind: to be <em>Structure-Ready</em>, allowing for the reliable and interoperable encoding and storage of information; and to be <em>Privacy-Ready</em>, ensuring that transmission of that data can occur in a privacy-protecting manner.</t>
      <ul spacing="normal">
        <li>
          <strong>Structure-Ready.</strong> Gordian Envelope is designed as a "smart document": a set of information about a subject. More than that, it's a meta-document that can contain or refer to other documents. It can support multiple data structures, from single data items, to simple hierarchies, to labeled property graphs, semantic triples, and other forms of structured graphs. Though its fundamental structure is a tree, it can be used to create Directed Acyclic Graphs (DAGs) through references within or between Envelopes.</li>
        <li>
          <strong>Privacy-Ready.</strong> Gordian Envelope protects privacy by affording progressive trust, allowing for holders (not just issuers) to minimally disclose information by using elision, and then to optionally increase that disclosure over time. Progressive trust in Gordian Envelopes is accomplished through the hashing of all elements, which also creates foundational support for signing and encryption. This directly addresses the data minimization suggested by "Privacy Considerations for Internet Protocols" <xref target="RFC6973"/> and also addresses topics such as Privacy, Accessibility, Censorship Resistance, Reliability, and Integrity, which are listed as guidelines in "Research into Human Rights Protocol Considerations" <xref target="RFC8280"/>.</li>
      </ul>
      <t>The following architectural decisions support these goals:</t>
      <ul spacing="normal">
        <li>
          <strong>Structured Merkle Tree.</strong> A variant of the Merkle Tree <xref target="MERKLE"/> structure is created by hashing the elements in the Envelope into a tree of digests. (In this "structured Merkle Tree", all nodes contain both semantic content and digests, rather than semantic content being limited to leaves.)</li>
        <li>
          <strong>Deterministic Representation.</strong> There is only one way to encode any semantic representation within a Gordian Envelope. This is accomplished through the use of Deterministic CBOR <xref target="DCBOR"/> and the sorting of the Envelope's assertions into a lexicographic order (not to be confused with sorting a CBOR encoding's map keys). Any Envelope that doesn't follow these strict rules will be rejected; as a result, separate actors assembling envelopes from the same information will converge on the same encoded structure.</li>
      </ul>
      <section anchor="elision-support">
        <name>Elision Support</name>
        <ul spacing="normal">
          <li>
            <strong>Holder-initiated Elision.</strong> Elision can be performed by the Holder of a Gordian Envelope, not just the Issuer.</li>
          <li>
            <strong>Granular Elision.</strong> Elision can be performed on any data within an Envelope including subjects, predicates and objects of assertions, assertions as a whole, and envelopes as a whole. This allows each entity to elide data as is appropriate for the management of their personal or business risk.</li>
          <li>
            <strong>Progressive Trust.</strong> The elision mechanics in Gordian Envelopes allow for progressive trust, where increasing amounts of data may be revealed over time.</li>
          <li>
            <strong>Consistent Hashing.</strong> Even when elided, digests for those parts of the Gordian Envelope remain the same. So constructs such as signatures remain verifiable even for elided documents.</li>
          <li>
            <strong>Reversible Elision.</strong> Elision can be reversed by the Holder of a Gordian Envelope, which means removed information can be selectively replaced without changing the digest tree.</li>
        </ul>
      </section>
      <section anchor="extensions">
        <name>Extensions</name>
        <t>This document is the base specification for Gordian Envelope, which is stable and useful by itself. However it is also designed to support optional extensions, to be specified in separate documents.</t>
        <t>A few such extensions may require adding new Envelope cases: these will extend the Envelope format itself, and will therefore need to be supported by Envelope encoders. Examples include symmetric encryption and compression which (like elision) allow for the transformation of Envelope elements without changing the digest tree.</t>
        <t>However, most extensions will be specified by defining the semantics of new subjects, predicates, and objects. Such extensions do not require extending the Envelope format but may be supported by tools. Examples include signatures, public-key encryption, digest decorrelation, intra- and inter-Envelope references using digests, expression evaluation and distributed function calls, diffing and merging envelopes, and inclusion proofs.</t>
        <t>Building on this base specification, we expect a robust ecosystem of extensions to emerge, facilitating a wide variety of applications.</t>
      </section>
    </section>
    <section anchor="terminology">
      <name>Terminology</name>
      <t>The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>", "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL
NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
"<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they
appear in all capitals, as shown here.</t>
      <?line -18?>

<t>This specification makes use of the following terminology:</t>
      <dl>
        <dt>byte</dt>
        <dd>
          <t>Used in its now-customary sense as a synonym for "octet".</t>
        </dd>
        <dt>element</dt>
        <dd>
          <t>Synonymous with "sub-Envelope". An Envelope is a tree of elements.</t>
        </dd>
        <dt>image</dt>
        <dd>
          <t>The source data from which a cryptographic digest is calculated.</t>
        </dd>
      </dl>
    </section>
    <section anchor="envelope-format-specification">
      <name>Envelope Format Specification</name>
      <t>This section is normative and specifies the Gordian Envelope binary format in terms of its CBOR components and their sequencing. The formal language used is the Concise Data Definition Language (CDDL) <xref target="RFC8610"/>. To be considered a well-formed Envelope, a sequence of bytes <bcp14>MUST</bcp14> conform to the Gordian dCBOR deterministic CBOR profile <xref target="DCBOR"/> and <bcp14>MUST</bcp14> conform to the specifications in this section.</t>
      <t>An Envelope is a tagged enumerated type with five cases. Here is the entire CDDL specification for the base Envelope format. Each case is discussed in detail below:</t>
      <sourcecode type="cddl"><![CDATA[
envelope = #6.200(envelope-content)
envelope-content =
    leaf /
    elided /
    node /
    assertion /
    wrapped

leaf = #6.24(bytes .dcbor any)

elided = sha256-digest
sha256-digest = bytes .size 32

node = [subject, + assertion-element]
subject = envelope-content
assertion-element = assertion / elided-assertion
elided-assertion = elided           ; MUST represent an assertion.

assertion = { predicate => object }
predicate = envelope-content
object = envelope-content

wrapped = envelope
]]></sourcecode>
      <t>Some of these cases create a hierarchical, recursive structure by including children that are themselves Envelopes. Two of these cases (<tt>leaf</tt> and <tt>elided</tt>) have no children. The <tt>node</tt> case adds one or more assertions to the Envelope, each of which is a child. The <tt>assertion</tt> case is a predicate/object pair, both of which are children. The <tt>wrapped</tt> case is used to wrap an entire Envelope including its assertions (its child), so that assertions can be made about the wrapped Envelope as a whole.</t>
      <section anchor="leaf-case-format">
        <name>Leaf Case Format</name>
        <t>A <tt>leaf</tt> case is used when the Envelope contains only user-defined CBOR content. It is tagged using <tt>#6.24</tt>, per <xref target="RFC8949"/> §3.4.5.1, "Encoded CBOR Data Item". See §4 of <xref target="CCDE"/> for CDDL support for dCBOR.</t>
        <sourcecode type="cddl"><![CDATA[
leaf = #6.24(bytes .dcbor any)
]]></sourcecode>
        <t>The <tt>leaf</tt> case can be discriminated from other Envelope case arms by the fact that it is the only one that is tagged using <tt>#6.24</tt>.</t>
        <t>To preserve deterministic encoding, authors of application-level data formats based on Envelope <bcp14>MUST</bcp14> only encode CBOR that conforms to dCBOR <xref target="DCBOR"/> in the <tt>leaf</tt> case. Care must be taken to ensure that leaf dCBOR follows best practices for deterministic encoding, such as clearly specifying when tags for nested structures <bcp14>MUST</bcp14> or <bcp14>MUST NOT</bcp14> be used.</t>
      </section>
      <section anchor="elided-case-format">
        <name>Elided Case Format</name>
        <t>An <tt>elided</tt> case is used as a placeholder for an element that has been elided. It consists solely of the elided Envelope's digest.</t>
        <sourcecode type="cddl"><![CDATA[
elided = sha256-digest
sha256-digest = bytes .size 32
]]></sourcecode>
        <t>The <tt>elided</tt> case can be discriminated from other Envelope case arms by the fact that it is the only one that is a CBOR byte string and always has a length of 32 bytes.</t>
        <t>If the method of producing the digest ever changes, the top-level Envelope tag <tt>#6.200</tt> <bcp14>MUST</bcp14> be changed to a new value, and the new method <bcp14>MUST</bcp14> be specified in a new document. This is to ensure that the digest tree remains consistent.</t>
      </section>
      <section anchor="node-case-format">
        <name>Node Case Format</name>
        <t>A <tt>node</tt> case is encoded as a CBOR array. A <tt>node</tt> case <bcp14>MUST</bcp14> be used when one or more assertions are present on the Envelope. A <tt>node</tt> case <bcp14>MUST NOT</bcp14> be present when there is not at least one assertion.</t>
        <t>The first element of the array is the Envelope's <tt>subject</tt>, followed by one or more <tt>assertion-element</tt>s, each of which <bcp14>MUST</bcp14> either be an <tt>assertion</tt> or an <tt>elided-assertion</tt>.</t>
        <t>The <tt>assertion-element</tt>s <bcp14>MUST</bcp14> appear in ascending lexicographic order by their digest (not to be confused with sorting a CBOR map's keys).</t>
        <t>The array <bcp14>MUST NOT</bcp14> contain any <tt>assertion-element</tt>s with identical digests.</t>
        <t>For an Envelope to be valid, any <tt>elided-assertion</tt> Envelopes in the <tt>node</tt> assertions <bcp14>MUST</bcp14>, if and when unelided, be found to be actual <tt>assertion</tt> case Envelopes having the same digest.</t>
        <sourcecode type="cddl"><![CDATA[
node = [subject, + assertion-element]
subject = envelope-content
assertion-element = assertion / elided-assertion
elided-assertion = elided           ; MUST represent an assertion.
]]></sourcecode>
        <t>The <tt>node</tt> case can be discriminated from other Envelope case arms by the fact that it is the only one that is a CBOR array.</t>
      </section>
      <section anchor="assertion-case-format">
        <name>Assertion Case Format</name>
        <t>An <tt>assertion</tt> case is used for each of the assertions on the subject of an Envelope. It is encoded as a CBOR map with exactly one map entry:</t>
        <ul spacing="normal">
          <li>The key of the map entry is the Envelope representing the predicate of the assertion.</li>
          <li>The value of the map entry is the Envelope representing the object of the assertion.</li>
        </ul>
        <sourcecode type="cddl"><![CDATA[
assertion = { predicate => object }
predicate = envelope-content
object = envelope-content
]]></sourcecode>
        <t>The <tt>assertion</tt> case can be discriminated from other Envelope case arms by the fact that it is the only one that is a CBOR map.</t>
      </section>
      <section anchor="wrapped-case-format">
        <name>Wrapped Case Format</name>
        <t>Assertions make semantic statements about an Envelope's subject. A <tt>wrapped</tt> case is used where an Envelope, including all its assertions, should be treated as a single element, e.g. for the purpose of adding assertions to an Envelope as a whole, including its assertions.</t>
        <sourcecode type="cddl"><![CDATA[
wrapped = envelope
]]></sourcecode>
        <t>The <tt>wrapped</tt> case can be discriminated from other Envelope case arms by the fact that it is the only one that is top-level CBOR Envelope, always tagged with <tt>#6.200</tt>.</t>
      </section>
    </section>
    <section anchor="computing-the-digest-tree">
      <name>Computing the Digest Tree</name>
      <t>This section specifies how the digests for each of the Envelope cases are computed and is normative. The examples in this section may be used as test vectors.</t>
      <t>Each of the five enumerated Envelope cases produces an image which is used as input to a cryptographic hash function to produce the digest of its contents.</t>
      <t>The overall digest of an Envelope is the digest of its specific case.</t>
      <t>In this section:</t>
      <ul spacing="normal">
        <li>
          <tt>digest(image)</tt> is the 32-byte hash produced by running the SHA-256 hash function on the input image.</li>
        <li>The <tt>.digest</tt> attribute is the digest of the named element computed as specified herein.</li>
        <li>The <tt>||</tt> operator represents the concatenation of byte sequences.</li>
      </ul>
      <t>Note that in the examples below, hexadecimal is shown for readability. All the hexadecimal you see is converted to binary before being hashed.</t>
      <section anchor="leaf-digest-calculation">
        <name>Leaf Digest Calculation</name>
        <t>The <tt>leaf</tt> case consists of any CBOR object conforming to dCBOR <xref target="DCBOR"/>. The Envelope image is the CBOR serialization of that object:</t>
        <artwork><![CDATA[
digest(cbor)
]]></artwork>
        <t><strong>Example</strong></t>
        <t>The CBOR serialization of the plaintext string <tt>"Hello"</tt> (not including the quotes) is:</t>
        <artwork><![CDATA[
65            # text(5)
   48656C6C6F # "Hello"
]]></artwork>
        <t>The following command line calculates the SHA-256 sum of this sequence:</t>
        <artwork><![CDATA[
$ echo "6548656C6C6F" | xxd -r -p | shasum --binary --algorithm 256 | \
    awk '{ print $1 }'
4d303dac9eed63573f6190e9c4191be619e03a7b3c21e9bb3d27ac1a55971e6b
]]></artwork>
        <t>Using the <tt>envelope</tt> command line tool <xref target="ENVELOPE-CLI"/>, we create an Envelope with this string as the subject and display the Envelope's digest. The digest below matches the one above.</t>
        <artwork><![CDATA[
$ envelope subject "Hello" | envelope digest --hex
4d303dac9eed63573f6190e9c4191be619e03a7b3c21e9bb3d27ac1a55971e6b
]]></artwork>
      </section>
      <section anchor="elided-digest-calculation">
        <name>Elided Digest Calculation</name>
        <t>The <tt>elided</tt> case declares its digest to be the digest of the Envelope for which it is a placeholder.</t>
        <t><strong>Example</strong></t>
        <t>If we create the Envelope from the leaf example above, elide it, and then request its digest:</t>
        <artwork><![CDATA[
$ envelope subject "Hello" | envelope elide | envelope digest --hex
4d303dac9eed63573f6190e9c4191be619e03a7b3c21e9bb3d27ac1a55971e6b
]]></artwork>
        <t>...we see that its digest is the same as its unelided form:</t>
        <artwork><![CDATA[
$ envelope subject "Hello" | envelope digest --hex
4d303dac9eed63573f6190e9c4191be619e03a7b3c21e9bb3d27ac1a55971e6b
]]></artwork>
      </section>
      <section anchor="node-digest-calculation">
        <name>Node Digest Calculation</name>
        <t>The Envelope image of the <tt>node</tt> case is the concatenation of the digest of its <tt>subject</tt> and the digests of its assertions sorted in ascending lexicographic order.</t>
        <t>With a <tt>node</tt> case, there <bcp14>MUST</bcp14> always be at least one assertion.</t>
        <artwork><![CDATA[
digest(subject.digest || assertion-0.digest ||
    assertion-1.digest || ... || assertion-n.digest)
]]></artwork>
        <t><strong>Example</strong></t>
        <t>We create four separate Envelopes and display their digests:</t>
        <artwork><![CDATA[
$ SUBJECT=`envelope subject "Alice"`
$ envelope digest --hex $SUBJECT
13941b487c1ddebce827b6ec3f46d982938acdc7e3b6a140db36062d9519dd2f

$ ASSERTION_0=`envelope subject assertion "knows" "Bob"`
$ envelope digest --hex $ASSERTION_0
78d666eb8f4c0977a0425ab6aa21ea16934a6bc97c6f0c3abaefac951c1714a2

$ ASSERTION_1=`envelope subject assertion "knows" "Carol"`
$ envelope digest --hex $ASSERTION_1
4012caf2d96bf3962514bcfdcf8dd70c351735dec72c856ec5cdcf2ee35d6a91

$ ASSERTION_2=`envelope subject assertion "knows" "Edward"`
$ envelope digest --hex $ASSERTION_2
65c3ebc3f056151a6091e738563dab4af8da1778da5a02afcd104560b612ca17
]]></artwork>
        <t>We combine the Envelopes into a single Envelope with three assertions:</t>
        <artwork><![CDATA[
$ ENVELOPE=`envelope assertion add envelope $ASSERTION_0 $SUBJECT | \
    envelope assertion add envelope $ASSERTION_1 | \
    envelope assertion add envelope $ASSERTION_2`

$ envelope $ENVELOPE
"Alice" [
    "knows": "Bob"
    "knows": "Carol"
    "knows": "Edward"
]

$ envelope digest --hex $ENVELOPE
6255e3b67ad935caf07b5dce5105d913dcfb82f0392d4d302f6d406e85ab4769
]]></artwork>
        <t>Note that in the Envelope notation representation above, the assertions are sorted alphabetically, with <tt>"knows": "Edward"</tt> coming last. But internally, the three assertions are ordered by digest in ascending lexicographic order, with "Carol" coming first because its digest starting with <tt>4012caf2</tt> is the lowest, as in the tree formatted display below:</t>
        <artwork><![CDATA[
$ envelope --tree $ENVELOPE
6255e3b6 NODE
    13941b48 subj "Alice"
    4012caf2 ASSERTION
        db7dd21c pred "knows"
        afb8122e obj "Carol"
    65c3ebc3 ASSERTION
        db7dd21c pred "knows"
        e9af7883 obj "Edward"
    78d666eb ASSERTION
        db7dd21c pred "knows"
        13b74194 obj "Bob"
]]></artwork>
        <t>To replicate this, we make a list of digests, starting with the subject, and then sort each assertion's digest in ascending lexicographic order:</t>
        <artwork><![CDATA[
13941b487c1ddebce827b6ec3f46d982938acdc7e3b6a140db36062d9519dd2f
4012caf2d96bf3962514bcfdcf8dd70c351735dec72c856ec5cdcf2ee35d6a91
65c3ebc3f056151a6091e738563dab4af8da1778da5a02afcd104560b612ca17
78d666eb8f4c0977a0425ab6aa21ea16934a6bc97c6f0c3abaefac951c1714a2
]]></artwork>
        <t>We then calculate the SHA-256 digest of the concatenation of these four digests. Note that this is the same digest as the composite Envelope's digest:</t>
        <artwork><![CDATA[
echo "13941b487c1ddebce827b6ec3f46d982938acdc7e3b6a140db36062d9519dd2f\
4012caf2d96bf3962514bcfdcf8dd70c351735dec72c856ec5cdcf2ee35d6a91\
65c3ebc3f056151a6091e738563dab4af8da1778da5a02afcd104560b612ca17\
78d666eb8f4c0977a0425ab6aa21ea16934a6bc97c6f0c3abaefac951c1714a2" | \
    xxd -r -p | shasum --binary --algorithm 256 | awk '{ print $1 }'
6255e3b67ad935caf07b5dce5105d913dcfb82f0392d4d302f6d406e85ab4769

$ envelope digest --hex $ENVELOPE
6255e3b67ad935caf07b5dce5105d913dcfb82f0392d4d302f6d406e85ab4769
]]></artwork>
      </section>
      <section anchor="assertion-digest-calculation">
        <name>Assertion Digest Calculation</name>
        <t>The Envelope image of the <tt>assertion</tt> case is the concatenation of the digests of the assertion's predicate and object, in that order:</t>
        <artwork><![CDATA[
digest(predicate.digest || object.digest)
]]></artwork>
        <t><strong>Example</strong></t>
        <t>We create an assertion from two separate Envelopes and display their digests:</t>
        <artwork><![CDATA[
$ PREDICATE=`envelope subject "knows"`
$ envelope digest --hex $PREDICATE
db7dd21c5169b4848d2a1bcb0a651c9617cdd90bae29156baaefbb2a8abef5ba

$ OBJECT=`envelope subject "Bob"`
$ envelope digest --hex $OBJECT
13b741949c37b8e09cc3daa3194c58e4fd6b2f14d4b1d0f035a46d6d5a1d3f11

$ ASSERTION=`envelope subject assertion "knows" "Bob"`
$ envelope digest --hex $ASSERTION
78d666eb8f4c0977a0425ab6aa21ea16934a6bc97c6f0c3abaefac951c1714a2
]]></artwork>
        <t>To replicate this, we make a list of the predicate digest and the object digest, in that order:</t>
        <artwork><![CDATA[
db7dd21c5169b4848d2a1bcb0a651c9617cdd90bae29156baaefbb2a8abef5ba
13b741949c37b8e09cc3daa3194c58e4fd6b2f14d4b1d0f035a46d6d5a1d3f11
]]></artwork>
        <t>We then calculate the SHA-256 digest of the concatenation of these two digests. Note that this is the same digest as the composite Envelope's digest:</t>
        <artwork><![CDATA[
echo "db7dd21c5169b4848d2a1bcb0a651c9617cdd90bae29156baaefbb2a8abef5ba\
13b741949c37b8e09cc3daa3194c58e4fd6b2f14d4b1d0f035a46d6d5a1d3f11" | \
    xxd -r -p | shasum --binary --algorithm 256 | awk '{ print $1 }'
78d666eb8f4c0977a0425ab6aa21ea16934a6bc97c6f0c3abaefac951c1714a2

$ envelope digest --hex $ASSERTION
78d666eb8f4c0977a0425ab6aa21ea16934a6bc97c6f0c3abaefac951c1714a2
]]></artwork>
      </section>
      <section anchor="wrapped-digest-calculation">
        <name>Wrapped Digest Calculation</name>
        <t>The Envelope image of the <tt>wrapped</tt> case is the digest of the wrapped Envelope:</t>
        <artwork><![CDATA[
digest(envelope.digest)
]]></artwork>
        <t><strong>Example</strong></t>
        <t>As above, we note the digest of a leaf Envelope is the digest of its CBOR:</t>
        <artwork><![CDATA[
$ envelope subject "Hello" | envelope digest --hex
4d303dac9eed63573f6190e9c4191be619e03a7b3c21e9bb3d27ac1a55971e6b

$ echo "6548656C6C6F" | xxd -r -p | shasum --binary --algorithm 256 | \
    awk '{ print $1 }'
4d303dac9eed63573f6190e9c4191be619e03a7b3c21e9bb3d27ac1a55971e6b
]]></artwork>
        <t>Now we note that the digest of a wrapped Envelope is the digest of the wrapped Envelope's digest:</t>
        <artwork><![CDATA[
$ envelope subject "Hello" | \
    envelope subject --wrapped | \
    envelope digest --hex
743a86a9f411b1441215fbbd3ece3de5206810e8a3dd8239182e123802677bd7

$ echo "4d303dac9eed63573f6190e9c4191be619e03a7b3c21e9bb\
3d27ac1a55971e6b" \
    | xxd -r -p | shasum --binary --algorithm 256 | awk '{ print $1 }'
743a86a9f411b1441215fbbd3ece3de5206810e8a3dd8239182e123802677bd7
]]></artwork>
      </section>
    </section>
    <section anchor="envelope-hierarchy">
      <name>Envelope Hierarchy</name>
      <t>This section is informative, and describes Envelopes from the perspective of their hierarchical structure and the various ways they can be formatted.</t>
      <t>Notionally an Envelope can be thought of as a <tt>subject</tt> and one or more <tt>predicate-object</tt> pairs called <tt>assertions</tt>.</t>
      <t>Note that the following example is <em>not</em> CDDL or CBOR diagnostic notation, but "Envelope notation," which is a convenient way to describe the structure of an Envelope:</t>
      <artwork><![CDATA[
subject [
    predicate0: object0
    predicate1: object1
    ...
    predicateN: objectN
]
]]></artwork>
      <t>A concrete example of this might be:</t>
      <artwork><![CDATA[
"Alice" [
    "knows": "Bob"
    "knows": "Carol"
    "knows": "Edward"
]
]]></artwork>
      <t>The notional concept of Envelope is helpful, but not technically accurate because Envelope is implemented structurally as an enumerated type consisting of five cases. This allows actual Envelope instances to be more flexible, for example a "bare assertion" consisting of a predicate-object pair with no subject, which is useful in some situations:</t>
      <artwork><![CDATA[
"knows": "Bob"
]]></artwork>
      <t>More common is the opposite case: a subject with no assertions:</t>
      <artwork><![CDATA[
"Alice"
]]></artwork>
      <t>In Envelopes, there are five distinct "positions" of elements, each of which is itself an Envelope and which therefore produces its own digest:</t>
      <ol spacing="normal" type="1"><li>Envelope</li>
        <li>Subject</li>
        <li>Assertion</li>
        <li>Predicate</li>
        <li>Object</li>
      </ol>
      <t>The examples above are printed in Envelope notation, which is designed to make the semantic content of Envelopes human-readable, but it doesn't show the actual digests associated with each of the positions. To see the structure more completely, we can display every element of the Envelope in "Tree Format":</t>
      <artwork><![CDATA[
6255e3b6 NODE
    13941b48 subj "Alice"
    4012caf2 ASSERTION
        db7dd21c pred "knows"
        afb8122e obj "Carol"
    65c3ebc3 ASSERTION
        db7dd21c pred "knows"
        e9af7883 obj "Edward"
    78d666eb ASSERTION
        db7dd21c pred "knows"
        13b74194 obj "Bob"
]]></artwork>
      <t>For easy recognition, Envelope trees only show the first four bytes of each digest, but internally all digests are 32 bytes.</t>
      <t>From the above Envelope and its tree, we make the following observations:</t>
      <ul spacing="normal">
        <li>The Envelope is a <tt>node</tt> case, which has the overall Envelope digest.</li>
        <li>The subject "Alice" has its own digest.</li>
        <li>Each of the three assertions have their own digests</li>
        <li>The predicate and object of each assertion each have their own digests.</li>
        <li>The assertions appear in the structure in ascending lexicographic order by digest, which is the actual order in which they are serialized, and which is distinct from Envelope notation, where they appear sorted alphabetically.</li>
      </ul>
      <t>The following subsections present each of the five enumerated Envelope cases in four different output formats:</t>
      <ul spacing="normal">
        <li>Envelope Notation</li>
        <li>Envelope Tree</li>
        <li>CBOR Diagnostic Notation</li>
        <li>CBOR hex</li>
      </ul>
      <t>These examples may be used as test vectors. In addition, each subsection starts with the <tt>envelope</tt> command line <xref target="ENVELOPE-CLI"/> needed to generate the Envelope being formatted.</t>
      <section anchor="leaf-case">
        <name>Leaf Case</name>
        <t><strong>Envelope CLI Command Line</strong></t>
        <artwork><![CDATA[
envelope subject "Alice"
]]></artwork>
        <t><strong>Envelope Notation</strong></t>
        <artwork><![CDATA[
"Alice"
]]></artwork>
        <t><strong>Tree</strong></t>
        <artwork><![CDATA[
13941b48 "Alice"
]]></artwork>
        <t><strong>CBOR Diagnostic Notation</strong></t>
        <artwork><![CDATA[
200(   / envelope /
   24("Alice")   / leaf /
)
]]></artwork>
        <t><strong>CBOR Hex</strong></t>
        <artwork><![CDATA[
D8 C8               # tag(200) envelope
   D8 18            # tag(24) leaf
      65            # text(5)
         416C696365 # "Alice"
]]></artwork>
      </section>
      <section anchor="elided-case">
        <name>Elided Case</name>
        <t><strong>Envelope CLI Command Line</strong></t>
        <artwork><![CDATA[
envelope subject "Alice" | envelope elide
]]></artwork>
        <t><strong>Envelope Notation</strong></t>
        <artwork><![CDATA[
ELIDED
]]></artwork>
        <t><strong>Tree</strong></t>
        <artwork><![CDATA[
13941b48 ELIDED
]]></artwork>
        <t><strong>CBOR Diagnostic Notation</strong></t>
        <artwork><![CDATA[
200(   / envelope /
   h'13941b487c1ddebce827b6ec3f46d982938acdc7e3b6a140db36062d9519dd2f'
)
]]></artwork>
        <t><strong>CBOR Hex</strong></t>
        <artwork><![CDATA[
D8 C8                                   # tag(200) envelope
   58 20                                # bytes(32)
      13941B487C1DDEBCE827B6EC3F46D982938ACDC7E3B6A140DB36062D9519DD2F
]]></artwork>
      </section>
      <section anchor="node-case">
        <name>Node Case</name>
        <t><strong>Envelope CLI Command Line</strong></t>
        <artwork><![CDATA[
envelope subject "Alice" | envelope assertion "knows" "Bob"
]]></artwork>
        <t><strong>Envelope Notation</strong></t>
        <artwork><![CDATA[
"Alice" [
    "knows": "Bob"
]
]]></artwork>
        <t><strong>Tree</strong></t>
        <artwork><![CDATA[
8955db5e NODE
    13941b48 subj "Alice"
    78d666eb ASSERTION
        db7dd21c pred "knows"
        13b74194 obj "Bob"
]]></artwork>
        <t><strong>CBOR Diagnostic Notation</strong></t>
        <artwork><![CDATA[
200(   / envelope /
   [
      24("Alice"),   / leaf /
      {
         24("knows"):   / leaf /
         24("Bob")   / leaf /
      }
   ]
)
]]></artwork>
        <t><strong>CBOR Hex</strong></t>
        <artwork><![CDATA[
D8 C8                     # tag(200) envelope
   82                     # array(2)
      D8 18               # tag(24) leaf
         65               # text(5)
            416C696365    # "Alice"
      A1                  # map(1)
         D8 18            # tag(24) leaf
            65            # text(5)
               6B6E6F7773 # "knows"
         D8 18            # tag(24) leaf
            63            # text(3)
               426F62     # "Bob"
]]></artwork>
      </section>
      <section anchor="assertion-case">
        <name>Assertion Case</name>
        <t><strong>Envelope CLI Command Line</strong></t>
        <artwork><![CDATA[
envelope subject assertion "knows" "Bob"
]]></artwork>
        <t><strong>Envelope Notation</strong></t>
        <artwork><![CDATA[
"knows": "Bob"
]]></artwork>
        <t><strong>Tree</strong></t>
        <artwork><![CDATA[
78d666eb ASSERTION
    db7dd21c pred "knows"
    13b74194 obj "Bob"
]]></artwork>
        <t><strong>CBOR Diagnostic Notation</strong></t>
        <artwork><![CDATA[
200(   / envelope /
   {
      24("knows"):   / leaf /
      24("Bob")   / leaf /
   }
)
]]></artwork>
        <t><strong>CBOR Hex</strong></t>
        <artwork><![CDATA[
D8 C8                  # tag(200) envelope
   A1                  # map(1)
      D8 18            # tag(24) leaf
         65            # text(5)
            6B6E6F7773 # "knows"
      D8 18            # tag(24) leaf
         63            # text(3)
            426F62     # "Bob"
]]></artwork>
      </section>
      <section anchor="wrapped-case">
        <name>Wrapped Case</name>
        <t><strong>Envelope CLI Command Line</strong></t>
        <artwork><![CDATA[
envelope subject "Alice" | envelope subject --wrapped
]]></artwork>
        <t><strong>Envelope Notation</strong></t>
        <artwork><![CDATA[
{
    "Alice"
}
]]></artwork>
        <t><strong>Tree</strong></t>
        <artwork><![CDATA[
2bc17c65 WRAPPED
    13941b48 subj "Alice"
]]></artwork>
        <t><strong>CBOR Diagnostic Notation</strong></t>
        <artwork><![CDATA[
200(   / envelope /
   200(   / envelope /
      24("Alice")   / leaf /
   )
)
]]></artwork>
        <t><strong>CBOR Hex</strong></t>
        <artwork><![CDATA[
D8 C8                  # tag(200) envelope
   D8 C8               # tag(200) envelope
      D8 18            # tag(24) leaf
         65            # text(5)
            416C696365 # "Alice"
]]></artwork>
      </section>
    </section>
    <section anchor="reference-implementations">
      <name>Reference Implementations</name>
      <t>This section is informative.</t>
      <t>The current reference implementations of Envelope are written in Swift <xref target="ENVELOPE-SWIFT"/> and Rust <xref target="ENVELOPE-RUST"/>.</t>
      <t>The <tt>envelope</tt> command line tool <xref target="ENVELOPE-CLI"/> is also written in Swift.</t>
    </section>
    <section anchor="security-considerations">
      <name>Security Considerations</name>
      <t>This section is informative unless noted otherwise.</t>
      <section anchor="cbor-considerations">
        <name>CBOR Considerations</name>
        <t>Generally, this document inherits the security considerations of CBOR <xref target="RFC8949"/>. Though CBOR has limited web usage, it has received strong usage in hardware, resulting in a mature specification. It also inherits the security considerations of Gordian dCBOR <xref target="DCBOR"/>.</t>
      </section>
      <section anchor="validation-requirements">
        <name>Validation Requirements</name>
        <t>Unlike HTML, Envelope is intended to be conservative in both what it encodes <em>and</em> what it accepts as valid. This means that receivers of Envelope-based documents should carefully validate them. Any deviation from the validation requirements of this specification <bcp14>MUST</bcp14> result in the rejection of the entire Envelope. Even after validation, Envelope contents should be treated with due skepticism at the application level.</t>
      </section>
      <section anchor="choice-of-sha-256-hash-primitive">
        <name>Choice of SHA-256 Hash Primitive</name>
        <t>Envelope uses the SHA-256 digest algorithm <xref target="RFC6234"/>, which is regarded as reliable and widely supported by many implementations in both software and hardware.</t>
      </section>
      <section anchor="correlated-digests">
        <name>Correlated Digests</name>
        <t>Elided Envelopes may in some cases inadvertently reveal information by transmitting digests that may be correlated to known information. In many cases this is of no consequence, but when necessary Envelopes can (when constructed) be "salted" by adding assertions that contain random data. This results in perturbing the digest tree, hence decorrelating it (after elision) from digests whose unelided contents are known.</t>
      </section>
      <section anchor="rfc-6973-considerations">
        <name>RFC 6973 Considerations</name>
        <t>"Privacy Considerations for Internet Protocols" <xref target="RFC6973"/> lists threats and guidelines related to privacy in internet protocols. Envelope is intended to help internet protocols easily adopt these considerations. It explicitly addresses the privacy-specific threats of correlation, secondary use, and disclosure by supporting the suggested guideline of Data Minimization.</t>
      </section>
      <section anchor="rfc-8280-considerations">
        <name>RFC 8280 Considerations</name>
        <t>"Research into Human Rights Protocol Considerations" <xref target="RFC8280"/> lists guidelines for human rights considerations in internet protocols. Envelope similarly adopts many of the guidelines there, improving privacy and censorship resistance through its hashed elision; and accessibility, heterogeneity support, reliability, and integrity through its fundamental data structures.</t>
      </section>
    </section>
    <section anchor="iana-considerations">
      <name>IANA Considerations</name>
      <section anchor="cbor-tags">
        <name>CBOR Tags</name>
        <t>This document requests that IANA <xref target="IANA-CBOR-TAGS"/> assign the following tag:</t>
        <table>
          <thead>
            <tr>
              <th align="left">Tag</th>
              <th align="left">Data Item</th>
              <th align="left">Semantics</th>
              <th align="left">Specification</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">200</td>
              <td align="left">multiple</td>
              <td align="left">Gordian Envelope</td>
              <td align="left">This document</td>
            </tr>
          </tbody>
        </table>
        <t>Points of contact:</t>
        <ul spacing="normal">
          <li>Christopher Allen <eref target="mailto:christophera@blockchaincommons.com">christophera@blockchaincommons.com</eref></li>
          <li>Wolf McNally <eref target="mailto:wolf@wolfmcnally.com">wolf@wolfmcnally.com</eref></li>
        </ul>
      </section>
      <section anchor="media-type">
        <name>Media Type</name>
        <t>The proposed media type <xref target="RFC6838"/> for Envelope is <tt>application/envelope+cbor</tt>. The authors understand that this will require this document to become an RFC before the media type can be registered.</t>
        <ul spacing="normal">
          <li>Type name: application</li>
          <li>Subtype name: envelope+cbor</li>
          <li>Required parameters: n/a</li>
          <li>Optional parameters: n/a</li>
          <li>Encoding considerations: binary</li>
          <li>Security considerations: See the previous section of this document</li>
          <li>Interoperability considerations: n/a</li>
          <li>Published specification: This document</li>
          <li>Applications that use this media type:  None yet, but it is expected that this format will be deployed in protocols and applications.</li>
          <li>
            <t>Additional information:
            </t>
            <ul spacing="normal">
              <li>Magic number(s): n/a</li>
              <li>File extension(s): .envelope</li>
              <li>Macintosh file type code(s): n/a</li>
            </ul>
          </li>
          <li>
            <t>Person &amp; email address to contact for further information:
            </t>
            <ul spacing="normal">
              <li>Christopher Allen <eref target="mailto:christophera@blockchaincommons.com">christophera@blockchaincommons.com</eref></li>
              <li>Wolf McNally <eref target="mailto:wolf@wolfmcnally.com">wolf@wolfmcnally.com</eref></li>
            </ul>
          </li>
          <li>Intended usage: COMMON</li>
          <li>Restrictions on usage: none</li>
          <li>
            <t>Author:
            </t>
            <ul spacing="normal">
              <li>Wolf McNally <eref target="mailto:wolf@wolfmcnally.com">wolf@wolfmcnally.com</eref></li>
            </ul>
          </li>
          <li>
            <t>Change controller:
            </t>
            <ul spacing="normal">
              <li>The IESG <eref target="mailto:iesg@ietf.org">iesg@ietf.org</eref></li>
            </ul>
          </li>
        </ul>
      </section>
    </section>
  </middle>
  <back>
    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <reference anchor="RFC8949">
          <front>
            <title>Concise Binary Object Representation (CBOR)</title>
            <author fullname="C. Bormann" initials="C." surname="Bormann"/>
            <author fullname="P. Hoffman" initials="P." surname="Hoffman"/>
            <date month="December" year="2020"/>
            <abstract>
              <t>The Concise Binary Object Representation (CBOR) is a data format whose design goals include the possibility of extremely small code size, fairly small message size, and extensibility without the need for version negotiation. These design goals make it different from earlier binary serializations such as ASN.1 and MessagePack.</t>
              <t>This document obsoletes RFC 7049, providing editorial improvements, new details, and errata fixes while keeping full compatibility with the interchange format of RFC 7049. It does not create a new version of the format.</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="94"/>
          <seriesInfo name="RFC" value="8949"/>
          <seriesInfo name="DOI" value="10.17487/RFC8949"/>
        </reference>
        <reference anchor="RFC8610">
          <front>
            <title>Concise Data Definition Language (CDDL): A Notational Convention to Express Concise Binary Object Representation (CBOR) and JSON Data Structures</title>
            <author fullname="H. Birkholz" initials="H." surname="Birkholz"/>
            <author fullname="C. Vigano" initials="C." surname="Vigano"/>
            <author fullname="C. Bormann" initials="C." surname="Bormann"/>
            <date month="June" year="2019"/>
            <abstract>
              <t>This document proposes a notational convention to express Concise Binary Object Representation (CBOR) data structures (RFC 7049). Its main goal is to provide an easy and unambiguous way to express structures for protocol messages and data formats that use CBOR or JSON.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8610"/>
          <seriesInfo name="DOI" value="10.17487/RFC8610"/>
        </reference>
        <reference anchor="RFC6838">
          <front>
            <title>Media Type Specifications and Registration Procedures</title>
            <author fullname="N. Freed" initials="N." surname="Freed"/>
            <author fullname="J. Klensin" initials="J." surname="Klensin"/>
            <author fullname="T. Hansen" initials="T." surname="Hansen"/>
            <date month="January" year="2013"/>
            <abstract>
              <t>This document defines procedures for the specification and registration of media types for use in HTTP, MIME, and other Internet protocols. This memo documents an Internet Best Current Practice.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="13"/>
          <seriesInfo name="RFC" value="6838"/>
          <seriesInfo name="DOI" value="10.17487/RFC6838"/>
        </reference>
        <reference anchor="DCBOR" target="https://datatracker.ietf.org/doc/draft-mcnally-deterministic-cbor/">
          <front>
            <title>Gordian dCBOR: A Deterministic CBOR Application Profile</title>
            <author>
              <organization/>
            </author>
            <date>n.d.</date>
          </front>
        </reference>
        <reference anchor="IANA-CBOR-TAGS" target="https://www.iana.org/assignments/cbor-tags/cbor-tags.xhtml">
          <front>
            <title>IANA, Concise Binary Object Representation (CBOR) Tags</title>
            <author>
              <organization/>
            </author>
            <date>n.d.</date>
          </front>
        </reference>
        <reference anchor="RFC6234">
          <front>
            <title>US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)</title>
            <author fullname="D. Eastlake 3rd" initials="D." surname="Eastlake 3rd"/>
            <author fullname="T. Hansen" initials="T." surname="Hansen"/>
            <date month="May" year="2011"/>
            <abstract>
              <t>Federal Information Processing Standard, FIPS</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6234"/>
          <seriesInfo name="DOI" value="10.17487/RFC6234"/>
        </reference>
        <reference anchor="ENVELOPE-SWIFT" target="https://github.com/blockchaincommons/BCSwiftEnvelope">
          <front>
            <title>Blockchain Commons Gordian Envelope for Swift</title>
            <author>
              <organization/>
            </author>
            <date>n.d.</date>
          </front>
        </reference>
        <reference anchor="ENVELOPE-RUST" target="https://github.com/blockchaincommons/bc-envelope-rust">
          <front>
            <title>Blockchain Commons Gordian Envelope for Rust</title>
            <author>
              <organization/>
            </author>
            <date>n.d.</date>
          </front>
        </reference>
        <reference anchor="ENVELOPE-CLI" target="https://github.com/BlockchainCommons/envelope-cli-swift">
          <front>
            <title>Envelope Command Line Tool</title>
            <author>
              <organization/>
            </author>
            <date>n.d.</date>
          </front>
        </reference>
        <reference anchor="CCDE" target="https://www.ietf.org/archive/id/draft-bormann-cbor-dcbor-02.html">
          <front>
            <title>Common CBOR Deterministic Encoding and Application Profiles</title>
            <author>
              <organization/>
            </author>
            <date>n.d.</date>
          </front>
        </reference>
        <reference anchor="RFC2119">
          <front>
            <title>Key words for use in RFCs to Indicate Requirement Levels</title>
            <author fullname="S. Bradner" initials="S." surname="Bradner"/>
            <date month="March" year="1997"/>
            <abstract>
              <t>In many standards track documents several words are used to signify the requirements in the specification. These words are often capitalized. This document defines these words as they should be interpreted in IETF documents. This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="2119"/>
          <seriesInfo name="DOI" value="10.17487/RFC2119"/>
        </reference>
        <reference anchor="RFC8174">
          <front>
            <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
            <author fullname="B. Leiba" initials="B." surname="Leiba"/>
            <date month="May" year="2017"/>
            <abstract>
              <t>RFC 2119 specifies common key words that may be used in protocol specifications. This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the defined special meanings.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="8174"/>
          <seriesInfo name="DOI" value="10.17487/RFC8174"/>
        </reference>
      </references>
      <references>
        <name>Informative References</name>
        <reference anchor="MERKLE" target="https://en.wikipedia.org/wiki/Merkle_tree">
          <front>
            <title>Merkle Tree</title>
            <author>
              <organization/>
            </author>
            <date>n.d.</date>
          </front>
        </reference>
        <reference anchor="RFC6973">
          <front>
            <title>Privacy Considerations for Internet Protocols</title>
            <author fullname="A. Cooper" initials="A." surname="Cooper"/>
            <author fullname="H. Tschofenig" initials="H." surname="Tschofenig"/>
            <author fullname="B. Aboba" initials="B." surname="Aboba"/>
            <author fullname="J. Peterson" initials="J." surname="Peterson"/>
            <author fullname="J. Morris" initials="J." surname="Morris"/>
            <author fullname="M. Hansen" initials="M." surname="Hansen"/>
            <author fullname="R. Smith" initials="R." surname="Smith"/>
            <date month="July" year="2013"/>
            <abstract>
              <t>This document offers guidance for developing privacy considerations for inclusion in protocol specifications. It aims to make designers, implementers, and users of Internet protocols aware of privacy-related design choices. It suggests that whether any individual RFC warrants a specific privacy considerations section will depend on the document's content.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6973"/>
          <seriesInfo name="DOI" value="10.17487/RFC6973"/>
        </reference>
        <reference anchor="RFC8280">
          <front>
            <title>Research into Human Rights Protocol Considerations</title>
            <author fullname="N. ten Oever" initials="N." surname="ten Oever"/>
            <author fullname="C. Cath" initials="C." surname="Cath"/>
            <date month="October" year="2017"/>
            <abstract>
              <t>This document aims to propose guidelines for human rights considerations, similar to the work done on the guidelines for privacy considerations (RFC 6973). The other parts of this document explain the background of the guidelines and how they were developed.</t>
              <t>This document is the first milestone in a longer-term research effort. It has been reviewed by the Human Rights Protocol Considerations (HRPC) Research Group and also by individuals from outside the research group.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8280"/>
          <seriesInfo name="DOI" value="10.17487/RFC8280"/>
        </reference>
      </references>
    </references>
    <?line 852?>

<section numbered="false" anchor="acknowledgments">
      <name>Acknowledgments</name>
      <t>The authors are grateful to Carsten Bormann for his review and helpful feedback.</t>
    </section>
  </back>
  <!-- ##markdown-source:
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
JvoyN5HasE/MC6DEXKkQx217/wO4Vr4mdnoAAA==

-->

</rfc>
