<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
]>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
<!-- generated by https://github.com/cabo/kramdown-rfc version 1.6.39 (Ruby 2.6.10) -->
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" ipr="trust200902" docName="draft-mcnally-envelope-10" category="exp" submissionType="IETF" tocInclude="true" sortRefs="true" symRefs="true" version="3">
  <!-- xml2rfc v2v3 conversion 3.18.0 -->
  <front>
    <title abbrev="Envelope">The Gordian Envelope Structured Data Format</title>
    <seriesInfo name="Internet-Draft" value="draft-mcnally-envelope-10"/>
    <author initials="W." surname="McNally" fullname="Wolf McNally">
      <organization>Blockchain Commons</organization>
      <address>
        <email>wolf@wolfmcnally.com</email>
      </address>
    </author>
    <author initials="C." surname="Allen" fullname="Christopher Allen">
      <organization>Blockchain Commons</organization>
      <address>
        <email>christophera@lifewithalacrity.com</email>
      </address>
    </author>
    <date year="2025" month="September" day="30"/>
    <area>Applications and Real-Time</area>
    <workgroup>Network Working Group</workgroup>
    <keyword>Internet-Draft</keyword>
    <abstract>
      <?line 55?>

<t>Gordian Envelope specifies a structured format for hierarchical binary data focused on the ability to transmit it in a privacy-focused way, offering support for privacy as described in RFC 6973 and human rights as described in RFC 8280. Envelopes are designed to facilitate "smart documents" and have a number of unique features including: easy representation of a variety of semantic structures, a built-in Merkle-like digest tree, deterministic representation using CBOR, and the ability for the holder of a document to selectively elide specific parts of a document without invalidating the digest tree structure. This document specifies the base Envelope format, which is designed to be extensible.</t>
    </abstract>
    <note removeInRFC="true">
      <name>Discussion Venues</name>
      <t>Source for this draft and an issue tracker can be found at
    <eref target="https://github.com/BlockchainCommons/envelope-internet-draft"/>.</t>
    </note>
  </front>
  <middle>
    <?line 59?>

<section anchor="introduction">
      <name>Introduction</name>
      <t>Gordian Envelope was designed with two key goals in mind: to be <em>Structure-Ready</em>, allowing for the reliable and interoperable encoding and storage of information; and to be <em>Privacy-Ready</em>, ensuring that transmission of that data can occur in a privacy-protecting manner.</t>
      <ul spacing="normal">
        <li>
          <strong>Structure-Ready.</strong> Gordian Envelope is designed as a "smart document": a set of information about a subject. More than that, it's a meta-document that can contain or refer to other documents. It can support multiple data structures, from single data items, to simple hierarchies, to labeled property graphs, semantic triples, and other forms of structured graphs. Though its fundamental structure is a tree, it can be used to create Directed Acyclic Graphs (DAGs) through references within or between Envelopes.</li>
        <li>
          <strong>Privacy-Ready.</strong> Gordian Envelope protects privacy by affording progressive trust, allowing for holders (not just issuers) to minimally disclose information by using elision, and then to optionally increase that disclosure over time. Progressive trust in Gordian Envelopes is accomplished through the hashing of all elements, which also creates foundational support for signing and encryption. This directly addresses the data minimization suggested by "Privacy Considerations for Internet Protocols" <xref target="RFC6973"/> and also addresses topics such as Privacy, Accessibility, Censorship Resistance, Reliability, and Integrity, which are listed as guidelines in "Research into Human Rights Protocol Considerations" <xref target="RFC8280"/>.</li>
      </ul>
      <t>The following architectural decisions support these goals:</t>
      <ul spacing="normal">
        <li>
          <strong>Structured Merkle Tree.</strong> A variant of the Merkle Tree <xref target="MERKLE"/> structure is created by hashing the elements in the Envelope into a tree of digests. (In this "structured Merkle Tree", all nodes contain both semantic content and digests, rather than semantic content being limited to leaves.)</li>
        <li>
          <strong>Deterministic Representation.</strong> There is only one way to encode any semantic representation within a Gordian Envelope. This is accomplished through the use of Deterministic CBOR <xref target="DCBOR"/> and the sorting of the Envelope's assertions into a lexicographic order (not to be confused with sorting a CBOR encoding's map keys). Any Envelope that doesn't follow these strict rules will be rejected; as a result, separate actors assembling envelopes from the same information will converge on the same encoded structure.</li>
      </ul>
      <section anchor="elision-support">
        <name>Elision Support</name>
        <ul spacing="normal">
          <li>
            <strong>Holder-initiated Elision.</strong> Elision can be performed by the Holder of a Gordian Envelope, not just the Issuer.</li>
          <li>
            <strong>Granular Elision.</strong> Elision can be performed on any data within an Envelope including subjects, predicates and objects of assertions, assertions as a whole, and envelopes as a whole. This allows each entity to elide data as is appropriate for the management of their personal or business risk.</li>
          <li>
            <strong>Progressive Trust.</strong> The elision mechanics in Gordian Envelopes allow for progressive trust, where increasing amounts of data may be revealed over time.</li>
          <li>
            <strong>Consistent Hashing.</strong> Even when elided, digests for those parts of the Gordian Envelope remain the same. So constructs such as signatures remain verifiable even for elided documents.</li>
          <li>
            <strong>Reversible Elision.</strong> Elision can be reversed by the Holder of a Gordian Envelope, which means removed information can be selectively replaced without changing the digest tree.</li>
        </ul>
      </section>
      <section anchor="extensions">
        <name>Extensions</name>
        <t>This document is the base specification for Gordian Envelope, which is stable and useful by itself. However it is also designed to support optional extensions, to be specified in separate documents.</t>
        <t>A few such extensions may require adding new Envelope cases: these will extend the Envelope format itself, and will therefore need to be supported by Envelope encoders. Examples include symmetric encryption and compression which (like elision) allow for the transformation of Envelope elements without changing the digest tree.</t>
        <t>However, most extensions will be specified by defining the semantics of new subjects, predicates, and objects. Such extensions do not require extending the Envelope format but may be supported by tools. Examples include signatures, public-key encryption, digest decorrelation, intra- and inter-Envelope references using digests, expression evaluation and distributed function calls, diffing and merging envelopes, and inclusion proofs.</t>
        <t>Building on this base specification, we expect a robust ecosystem of extensions to emerge, facilitating a wide variety of applications.</t>
      </section>
    </section>
    <section anchor="terminology">
      <name>Terminology</name>
      <t>The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>", "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL
NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
"<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be interpreted as
described in BCPÂ 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they
appear in all capitals, as shown here.</t>
      <?line -18?>

<t>This specification makes use of the following terminology:</t>
      <dl>
        <dt>byte</dt>
        <dd>
          <t>Used in its now-customary sense as a synonym for "octet".</t>
        </dd>
        <dt>element</dt>
        <dd>
          <t>Synonymous with "sub-Envelope". An Envelope is a tree of elements.</t>
        </dd>
        <dt>image</dt>
        <dd>
          <t>The source data from which a cryptographic digest is calculated.</t>
        </dd>
      </dl>
    </section>
    <section anchor="envelope-format-specification">
      <name>Envelope Format Specification</name>
      <t>This section is normative and specifies the Gordian Envelope binary format in terms of its CBOR components and their sequencing. The formal language used is the Concise Data Definition Language (CDDL) <xref target="RFC8610"/>. To be considered a well-formed Envelope, a sequence of bytes <bcp14>MUST</bcp14> conform to the Gordian dCBOR deterministic CBOR profile <xref target="DCBOR"/> and <bcp14>MUST</bcp14> conform to the specifications in this section.</t>
      <t>An Envelope is a tagged enumerated type with five cases. Here is the entire CDDL specification for the base Envelope format. Each case is discussed in detail below:</t>
      <sourcecode type="cddl"><![CDATA[
envelope = #6.200(envelope-content)
envelope-content =
    leaf /
    elided /
    node /
    assertion /
    wrapped

leaf = #6.201(any)

elided = sha256-digest
sha256-digest = bytes .size 32

node = [subject, + assertion-element]
subject = envelope-content
assertion-element = assertion / elided-assertion
elided-assertion = elided           ; MUST represent an assertion.

assertion = { predicate => object }
predicate = envelope-content
object = envelope-content

wrapped = envelope
]]></sourcecode>
      <t>Some of these cases create a hierarchical, recursive structure by including children that are themselves Envelopes. Two of these cases (<tt>leaf</tt> and <tt>elided</tt>) have no children. The <tt>node</tt> case adds one or more assertions to the Envelope, each of which is a child. The <tt>assertion</tt> case is a predicate/object pair, both of which are children. The <tt>wrapped</tt> case is used to wrap an entire Envelope including its assertions (its child), so that assertions can be made about the wrapped Envelope as a whole.</t>
      <section anchor="leaf-case-format">
        <name>Leaf Case Format</name>
        <t>A <tt>leaf</tt> case is used when the Envelope contains only user-defined CBOR content. It is tagged using <tt>#6.201</tt>, "encapsulated dCBOR", per <xref target="DCBOR"/>.</t>
        <sourcecode type="cddl"><![CDATA[
leaf = #6.201(any)
]]></sourcecode>
        <t>The <tt>leaf</tt> case can be discriminated from other Envelope case arms by the fact that it is the only one that is tagged using <tt>#6.201</tt>.</t>
        <t>To preserve deterministic encoding, authors of application-level data formats based on Envelope <bcp14>MUST</bcp14> only encode CBOR that conforms to dCBOR <xref target="DCBOR"/> in the <tt>leaf</tt> case. Care must be taken to ensure that leaf dCBOR follows best practices for deterministic encoding, such as clearly specifying when tags for nested structures <bcp14>MUST</bcp14> or <bcp14>MUST NOT</bcp14> be used.</t>
      </section>
      <section anchor="elided-case-format">
        <name>Elided Case Format</name>
        <t>An <tt>elided</tt> case is used as a placeholder for an element that has been elided. It consists solely of the elided Envelope's digest.</t>
        <sourcecode type="cddl"><![CDATA[
elided = sha256-digest
sha256-digest = bytes .size 32
]]></sourcecode>
        <t>The <tt>elided</tt> case can be discriminated from other Envelope case arms by the fact that it is the only one that is a CBOR byte string and always has a length of 32 bytes.</t>
        <t>If the method of producing the digest ever changes, the top-level Envelope tag <tt>#6.200</tt> <bcp14>MUST</bcp14> be changed to a new value, and the new method <bcp14>MUST</bcp14> be specified in a new document. This is to ensure that the digest tree remains consistent.</t>
      </section>
      <section anchor="node-case-format">
        <name>Node Case Format</name>
        <t>A <tt>node</tt> case is encoded as a CBOR array. A <tt>node</tt> case <bcp14>MUST</bcp14> be used when one or more assertions are present on the Envelope. A <tt>node</tt> case <bcp14>MUST NOT</bcp14> be present when there is not at least one assertion.</t>
        <t>The first element of the array is the Envelope's <tt>subject</tt>, followed by one or more <tt>assertion-element</tt>s, each of which <bcp14>MUST</bcp14> either be an <tt>assertion</tt> or an <tt>elided-assertion</tt>.</t>
        <t>The <tt>assertion-element</tt>s <bcp14>MUST</bcp14> appear in ascending lexicographic order by their digest (not to be confused with sorting a CBOR map's keys).</t>
        <t>The array <bcp14>MUST NOT</bcp14> contain any <tt>assertion-element</tt>s with identical digests.</t>
        <t>For an Envelope to be valid, any <tt>elided-assertion</tt> Envelopes in the <tt>node</tt> assertions <bcp14>MUST</bcp14>, if and when unelided, be found to be actual <tt>assertion</tt> case Envelopes having the same digest.</t>
        <sourcecode type="cddl"><![CDATA[
node = [subject, + assertion-element]
subject = envelope-content
assertion-element = assertion / elided-assertion
elided-assertion = elided           ; MUST represent an assertion.
]]></sourcecode>
        <t>The <tt>node</tt> case can be discriminated from other Envelope case arms by the fact that it is the only one that is a CBOR array.</t>
      </section>
      <section anchor="assertion-case-format">
        <name>Assertion Case Format</name>
        <t>An <tt>assertion</tt> case is used for each of the assertions on the subject of an Envelope. It is encoded as a CBOR map with exactly one map entry:</t>
        <ul spacing="normal">
          <li>The key of the map entry is the Envelope representing the predicate of the assertion.</li>
          <li>The value of the map entry is the Envelope representing the object of the assertion.</li>
        </ul>
        <sourcecode type="cddl"><![CDATA[
assertion = { predicate => object }
predicate = envelope-content
object = envelope-content
]]></sourcecode>
        <t>The <tt>assertion</tt> case can be discriminated from other Envelope case arms by the fact that it is the only one that is a CBOR map.</t>
      </section>
      <section anchor="wrapped-case-format">
        <name>Wrapped Case Format</name>
        <t>Assertions make semantic statements about an Envelope's subject. A <tt>wrapped</tt> case is used where an Envelope, including all its assertions, should be treated as a single element, e.g. for the purpose of adding assertions to an Envelope as a whole, including its assertions.</t>
        <sourcecode type="cddl"><![CDATA[
wrapped = envelope
]]></sourcecode>
        <t>The <tt>wrapped</tt> case can be discriminated from other Envelope case arms by the fact that it is the only one that is top-level CBOR Envelope, always tagged with <tt>#6.200</tt>.</t>
      </section>
    </section>
    <section anchor="computing-the-digest-tree">
      <name>Computing the Digest Tree</name>
      <t>This section specifies how the digests for each of the Envelope cases are computed and is normative. The examples in this section may be used as test vectors.</t>
      <t>Each of the five enumerated Envelope cases produces an image which is used as input to a cryptographic hash function to produce the digest of its contents.</t>
      <t>The overall digest of an Envelope is the digest of its specific case.</t>
      <t>In this section:</t>
      <ul spacing="normal">
        <li>
          <tt>digest(image)</tt> is the 32-byte hash produced by running the SHA-256 hash function on the input image.</li>
        <li>The <tt>.digest</tt> attribute is the digest of the named element computed as specified herein.</li>
        <li>The <tt>||</tt> operator represents the concatenation of byte sequences.</li>
      </ul>
      <t>Note that in the examples below, hexadecimal is shown for readability. All the hexadecimal you see is converted to binary before being hashed.</t>
      <section anchor="leaf-digest-calculation">
        <name>Leaf Digest Calculation</name>
        <t>The <tt>leaf</tt> case consists of any CBOR object conforming to dCBOR <xref target="DCBOR"/>. The Envelope image is the CBOR serialization of that object:</t>
        <artwork><![CDATA[
digest(cbor)
]]></artwork>
        <t><strong>Example</strong></t>
        <t>The CBOR serialization of the plaintext string <tt>"Hello"</tt> (not including the quotes) is:</t>
        <artwork><![CDATA[
65            # text(5)
   48656C6C6F # "Hello"
]]></artwork>
        <t>The following command line calculates the SHA-256 sum of this sequence:</t>
        <artwork><![CDATA[
$ echo "6548656C6C6F" | xxd -r -p | shasum --binary --algorithm 256 | \
    awk '{ print $1 }'
4d303dac9eed63573f6190e9c4191be619e03a7b3c21e9bb3d27ac1a55971e6b
]]></artwork>
        <t>Using the <tt>envelope</tt> command line tool <xref target="ENVELOPE-CLI"/>, we create an Envelope with this string as the subject and display the Envelope's digest. The digest below matches the one above.</t>
        <artwork><![CDATA[
$ envelope subject type string "Hello" | envelope digest --hex
4d303dac9eed63573f6190e9c4191be619e03a7b3c21e9bb3d27ac1a55971e6b
]]></artwork>
      </section>
      <section anchor="elided-digest-calculation">
        <name>Elided Digest Calculation</name>
        <t>The <tt>elided</tt> case declares its digest to be the digest of the Envelope for which it is a placeholder.</t>
        <t><strong>Example</strong></t>
        <t>If we create the Envelope from the leaf example above, elide it, and then request its digest:</t>
        <artwork><![CDATA[
$ envelope subject type string "Hello" | envelope elide revealing "" | envelope digest --hex
4d303dac9eed63573f6190e9c4191be619e03a7b3c21e9bb3d27ac1a55971e6b
]]></artwork>
        <t>...we see that its digest is the same as its unelided form:</t>
        <artwork><![CDATA[
$ envelope subject type string "Hello" | envelope digest --hex
4d303dac9eed63573f6190e9c4191be619e03a7b3c21e9bb3d27ac1a55971e6b
]]></artwork>
      </section>
      <section anchor="node-digest-calculation">
        <name>Node Digest Calculation</name>
        <t>The Envelope image of the <tt>node</tt> case is the concatenation of the digest of its <tt>subject</tt> and the digests of its assertions sorted in ascending lexicographic order.</t>
        <t>With a <tt>node</tt> case, there <bcp14>MUST</bcp14> always be at least one assertion.</t>
        <artwork><![CDATA[
digest(subject.digest || assertion-0.digest ||
    assertion-1.digest || ... || assertion-n.digest)
]]></artwork>
        <t><strong>Example</strong></t>
        <t>We create four separate Envelopes and display their digests:</t>
        <artwork><![CDATA[
$ SUBJECT=`envelope subject type string "Alice"`
$ envelope digest --hex $SUBJECT
13941b487c1ddebce827b6ec3f46d982938acdc7e3b6a140db36062d9519dd2f

$ ASSERTION_0=`envelope subject assertion string "knows" string "Bob"`
$ envelope digest --hex $ASSERTION_0
78d666eb8f4c0977a0425ab6aa21ea16934a6bc97c6f0c3abaefac951c1714a2

$ ASSERTION_1=`envelope subject assertion string "knows" string "Carol"`
$ envelope digest --hex $ASSERTION_1
4012caf2d96bf3962514bcfdcf8dd70c351735dec72c856ec5cdcf2ee35d6a91

$ ASSERTION_2=`envelope subject assertion string "knows" string "Edward"`
$ envelope digest --hex $ASSERTION_2
65c3ebc3f056151a6091e738563dab4af8da1778da5a02afcd104560b612ca17
]]></artwork>
        <t>We combine the Envelopes into a single Envelope with three assertions:</t>
        <artwork><![CDATA[
$ ENVELOPE=`envelope assertion add envelope $ASSERTION_0 $SUBJECT | \
    envelope assertion add envelope $ASSERTION_1 | \
    envelope assertion add envelope $ASSERTION_2`

$ envelope format $ENVELOPE
"Alice" [
    "knows": "Bob"
    "knows": "Carol"
    "knows": "Edward"
]

$ envelope digest --hex $ENVELOPE
6255e3b67ad935caf07b5dce5105d913dcfb82f0392d4d302f6d406e85ab4769
]]></artwork>
        <t>Note that in the Envelope notation representation above, the assertions are sorted alphabetically, with <tt>"knows": "Edward"</tt> coming last. But internally, the three assertions are ordered by digest in ascending lexicographic order, with "Carol" coming first because its digest starting with <tt>4012caf2</tt> is the lowest, as in the tree formatted display below:</t>
        <artwork><![CDATA[
$ envelope format --type tree $ENVELOPE
6255e3b6 NODE
    13941b48 subj "Alice"
    4012caf2 ASSERTION
        db7dd21c pred "knows"
        afb8122e obj "Carol"
    65c3ebc3 ASSERTION
        db7dd21c pred "knows"
        e9af7883 obj "Edward"
    78d666eb ASSERTION
        db7dd21c pred "knows"
        13b74194 obj "Bob"
]]></artwork>
        <t>To replicate this, we make a list of digests, starting with the subject, and then sort each assertion's digest in ascending lexicographic order:</t>
        <artwork><![CDATA[
13941b487c1ddebce827b6ec3f46d982938acdc7e3b6a140db36062d9519dd2f
4012caf2d96bf3962514bcfdcf8dd70c351735dec72c856ec5cdcf2ee35d6a91
65c3ebc3f056151a6091e738563dab4af8da1778da5a02afcd104560b612ca17
78d666eb8f4c0977a0425ab6aa21ea16934a6bc97c6f0c3abaefac951c1714a2
]]></artwork>
        <t>We then calculate the SHA-256 digest of the concatenation of these four digests. Note that this is the same digest as the composite Envelope's digest:</t>
        <artwork><![CDATA[
echo "13941b487c1ddebce827b6ec3f46d982938acdc7e3b6a140db36062d9519dd2f\
4012caf2d96bf3962514bcfdcf8dd70c351735dec72c856ec5cdcf2ee35d6a91\
65c3ebc3f056151a6091e738563dab4af8da1778da5a02afcd104560b612ca17\
78d666eb8f4c0977a0425ab6aa21ea16934a6bc97c6f0c3abaefac951c1714a2" | \
    xxd -r -p | shasum --binary --algorithm 256 | awk '{ print $1 }'
6255e3b67ad935caf07b5dce5105d913dcfb82f0392d4d302f6d406e85ab4769

$ envelope digest --hex $ENVELOPE
6255e3b67ad935caf07b5dce5105d913dcfb82f0392d4d302f6d406e85ab4769
]]></artwork>
      </section>
      <section anchor="assertion-digest-calculation">
        <name>Assertion Digest Calculation</name>
        <t>The Envelope image of the <tt>assertion</tt> case is the concatenation of the digests of the assertion's predicate and object, in that order:</t>
        <artwork><![CDATA[
digest(predicate.digest || object.digest)
]]></artwork>
        <t><strong>Example</strong></t>
        <t>We create an assertion from two separate Envelopes and display their digests:</t>
        <artwork><![CDATA[
$ PREDICATE=`envelope subject type string "knows"`
$ envelope digest --hex $PREDICATE
db7dd21c5169b4848d2a1bcb0a651c9617cdd90bae29156baaefbb2a8abef5ba

$ OBJECT=`envelope subject type string "Bob"`
$ envelope digest --hex $OBJECT
13b741949c37b8e09cc3daa3194c58e4fd6b2f14d4b1d0f035a46d6d5a1d3f11

$ ASSERTION=`envelope subject assertion string "knows" string "Bob"`
$ envelope digest --hex $ASSERTION
78d666eb8f4c0977a0425ab6aa21ea16934a6bc97c6f0c3abaefac951c1714a2
]]></artwork>
        <t>To replicate this, we make a list of the predicate digest and the object digest, in that order:</t>
        <artwork><![CDATA[
db7dd21c5169b4848d2a1bcb0a651c9617cdd90bae29156baaefbb2a8abef5ba
13b741949c37b8e09cc3daa3194c58e4fd6b2f14d4b1d0f035a46d6d5a1d3f11
]]></artwork>
        <t>We then calculate the SHA-256 digest of the concatenation of these two digests. Note that this is the same digest as the composite Envelope's digest:</t>
        <artwork><![CDATA[
echo "db7dd21c5169b4848d2a1bcb0a651c9617cdd90bae29156baaefbb2a8abef5ba\
13b741949c37b8e09cc3daa3194c58e4fd6b2f14d4b1d0f035a46d6d5a1d3f11" | \
    xxd -r -p | shasum --binary --algorithm 256 | awk '{ print $1 }'
78d666eb8f4c0977a0425ab6aa21ea16934a6bc97c6f0c3abaefac951c1714a2

$ envelope digest --hex $ASSERTION
78d666eb8f4c0977a0425ab6aa21ea16934a6bc97c6f0c3abaefac951c1714a2
]]></artwork>
      </section>
      <section anchor="wrapped-digest-calculation">
        <name>Wrapped Digest Calculation</name>
        <t>The Envelope image of the <tt>wrapped</tt> case is the digest of the wrapped Envelope:</t>
        <artwork><![CDATA[
digest(envelope.digest)
]]></artwork>
        <t><strong>Example</strong></t>
        <t>As above, we note the digest of a leaf Envelope is the digest of its CBOR:</t>
        <artwork><![CDATA[
$ envelope subject type string "Hello" | envelope digest --hex
4d303dac9eed63573f6190e9c4191be619e03a7b3c21e9bb3d27ac1a55971e6b

$ echo "6548656C6C6F" | xxd -r -p | shasum --binary --algorithm 256 | \
    awk '{ print $1 }'
4d303dac9eed63573f6190e9c4191be619e03a7b3c21e9bb3d27ac1a55971e6b
]]></artwork>
        <t>Now we note that the digest of a wrapped Envelope is the digest of the wrapped Envelope's digest:</t>
        <artwork><![CDATA[
$ envelope subject type string "Hello" | \
    envelope subject type wrapped | \
    envelope digest --hex
743a86a9f411b1441215fbbd3ece3de5206810e8a3dd8239182e123802677bd7

$ echo "4d303dac9eed63573f6190e9c4191be619e03a7b3c21e9bb\
3d27ac1a55971e6b" \
    | xxd -r -p | shasum --binary --algorithm 256 | awk '{ print $1 }'
743a86a9f411b1441215fbbd3ece3de5206810e8a3dd8239182e123802677bd7
]]></artwork>
      </section>
    </section>
    <section anchor="envelope-hierarchy">
      <name>Envelope Hierarchy</name>
      <t>This section is informative, and describes Envelopes from the perspective of their hierarchical structure and the various ways they can be formatted.</t>
      <t>Notionally an Envelope can be thought of as a <tt>subject</tt> and one or more <tt>predicate-object</tt> pairs called <tt>assertions</tt>.</t>
      <t>Note that the following example is <em>not</em> CDDL or CBOR diagnostic notation, but "Envelope notation," which is a convenient way to describe the structure of an Envelope:</t>
      <artwork><![CDATA[
subject [
    predicate0: object0
    predicate1: object1
    ...
    predicateN: objectN
]
]]></artwork>
      <t>A concrete example of this might be:</t>
      <artwork><![CDATA[
"Alice" [
    "knows": "Bob"
    "knows": "Carol"
    "knows": "Edward"
]
]]></artwork>
      <t>The notional concept of Envelope is helpful, but not technically accurate because Envelope is implemented structurally as an enumerated type consisting of five cases. This allows actual Envelope instances to be more flexible, for example a "bare assertion" consisting of a predicate-object pair with no subject, which is useful in some situations:</t>
      <artwork><![CDATA[
"knows": "Bob"
]]></artwork>
      <t>More common is the opposite case, a subject with no assertions:</t>
      <artwork><![CDATA[
"Alice"
]]></artwork>
      <t>In Envelopes, there are five distinct "positions" of elements, each of which is itself an Envelope and which therefore produces its own digest:</t>
      <ol spacing="normal" type="1"><li>Envelope</li>
        <li>Subject</li>
        <li>Assertion</li>
        <li>Predicate</li>
        <li>Object</li>
      </ol>
      <t>The examples above are printed in Envelope notation, which is designed to make the semantic content of Envelopes human-readable, but it doesn't show the actual digests associated with each of the positions. To see the structure more completely, we can display every element of the Envelope in "Tree Format":</t>
      <artwork><![CDATA[
6255e3b6 NODE
    13941b48 subj "Alice"
    4012caf2 ASSERTION
        db7dd21c pred "knows"
        afb8122e obj "Carol"
    65c3ebc3 ASSERTION
        db7dd21c pred "knows"
        e9af7883 obj "Edward"
    78d666eb ASSERTION
        db7dd21c pred "knows"
        13b74194 obj "Bob"
]]></artwork>
      <t>For easy recognition, Envelope trees only show the first four bytes of each digest, but internally all digests are 32 bytes.</t>
      <t>From the above Envelope and its tree, we make the following observations:</t>
      <ul spacing="normal">
        <li>The Envelope is a <tt>node</tt> case, which has the overall Envelope digest.</li>
        <li>The subject "Alice" has its own digest.</li>
        <li>Each of the three assertions have their own digests</li>
        <li>The predicate and object of each assertion each have their own digests.</li>
        <li>The assertions appear in the structure in ascending lexicographic order by digest, which is the actual order in which they are serialized, and which is distinct from Envelope notation, where they appear sorted alphabetically.</li>
      </ul>
      <t>The following subsections present each of the five enumerated Envelope cases in four different output formats:</t>
      <ul spacing="normal">
        <li>Envelope Notation</li>
        <li>Envelope Tree</li>
        <li>CBOR Diagnostic Notation</li>
        <li>CBOR hex</li>
      </ul>
      <t>These examples may be used as test vectors. In addition, each subsection starts with the <tt>envelope</tt> command line <xref target="ENVELOPE-CLI"/> needed to generate the Envelope being formatted.</t>
      <section anchor="leaf-case">
        <name>Leaf Case</name>
        <t><strong>Envelope CLI Command Line</strong></t>
        <artwork><![CDATA[
envelope subject type string "Alice"
]]></artwork>
        <t><strong>Envelope Notation</strong></t>
        <artwork><![CDATA[
"Alice"
]]></artwork>
        <t><strong>Tree</strong></t>
        <artwork><![CDATA[
13941b48 "Alice"
]]></artwork>
        <t><strong>CBOR Diagnostic Notation</strong></t>
        <artwork><![CDATA[
200(   / envelope /
   201("Alice")   / leaf /
)
]]></artwork>
        <t><strong>CBOR Hex</strong></t>
        <artwork><![CDATA[
d8 c8               # tag(200) envelope
   d8 c9            # tag(201) leaf
      65            # text(5)
         416c696365 # "Alice"
]]></artwork>
      </section>
      <section anchor="elided-case">
        <name>Elided Case</name>
        <t><strong>Envelope CLI Command Line</strong></t>
        <artwork><![CDATA[
envelope subject type string "Alice" | envelope elide revealing ""
]]></artwork>
        <t><strong>Envelope Notation</strong></t>
        <artwork><![CDATA[
ELIDED
]]></artwork>
        <t><strong>Tree</strong></t>
        <artwork><![CDATA[
13941b48 ELIDED
]]></artwork>
        <t><strong>CBOR Diagnostic Notation</strong></t>
        <artwork><![CDATA[
200(   / envelope /
   h'13941b487c1ddebce827b6ec3f46d982938acdc7e3b6a140db36062d9519dd2f'
)
]]></artwork>
        <t><strong>CBOR Hex</strong></t>
        <artwork><![CDATA[
d8 c8                                   # tag(200) envelope
   58 20                                # bytes(32)
      13941b487c1ddebce827b6ec3f46d982938acdc7e3b6a140db36062d9519dd2f
]]></artwork>
      </section>
      <section anchor="node-case">
        <name>Node Case</name>
        <t><strong>Envelope CLI Command Line</strong></t>
        <artwork><![CDATA[
envelope subject type string "Alice" | envelope assertion add pred-obj string "knows" string "Bob"
]]></artwork>
        <t><strong>Envelope Notation</strong></t>
        <artwork><![CDATA[
"Alice" [
    "knows": "Bob"
]
]]></artwork>
        <t><strong>Tree</strong></t>
        <artwork><![CDATA[
8955db5e NODE
    13941b48 subj "Alice"
    78d666eb ASSERTION
        db7dd21c pred "knows"
        13b74194 obj "Bob"
]]></artwork>
        <t><strong>CBOR Diagnostic Notation</strong></t>
        <artwork><![CDATA[
200(   / envelope /
   [
      201("Alice"),   / leaf /
      {
         201("knows"):   / leaf /
         201("Bob")   / leaf /
      }
   ]
)
]]></artwork>
        <t><strong>CBOR Hex</strong></t>
        <artwork><![CDATA[
d8 c8                     # tag(200) envelope
   82                     # array(2)
      d8 c9               # tag(201) leaf
         65               # text(5)
            416c696365    # "Alice"
      a1                  # map(1)
         d8 c9            # tag(201) leaf
            65            # text(5)
               6b6e6f7773 # "knows"
         d8 c9            # tag(201) leaf
            63            # text(3)
               426f62     # "Bob"
]]></artwork>
      </section>
      <section anchor="assertion-case">
        <name>Assertion Case</name>
        <t><strong>Envelope CLI Command Line</strong></t>
        <artwork><![CDATA[
envelope subject assertion string "knows" string "Bob"
]]></artwork>
        <t><strong>Envelope Notation</strong></t>
        <artwork><![CDATA[
"knows": "Bob"
]]></artwork>
        <t><strong>Tree</strong></t>
        <artwork><![CDATA[
78d666eb ASSERTION
    db7dd21c pred "knows"
    13b74194 obj "Bob"
]]></artwork>
        <t><strong>CBOR Diagnostic Notation</strong></t>
        <artwork><![CDATA[
200(   / envelope /
   {
      201("knows"):   / leaf /
      201("Bob")   / leaf /
   }
)
]]></artwork>
        <t><strong>CBOR Hex</strong></t>
        <artwork><![CDATA[
d8 c8                  # tag(200) envelope
   a1                  # map(1)
      d8 c9            # tag(201) leaf
         65            # text(5)
            6b6e6f7773 # "knows"
      d8 c9            # tag(201) leaf
         63            # text(3)
            426f62     # "Bob"
]]></artwork>
      </section>
      <section anchor="wrapped-case">
        <name>Wrapped Case</name>
        <t><strong>Envelope CLI Command Line</strong></t>
        <artwork><![CDATA[
envelope subject type string "Alice" | envelope subject type wrapped
]]></artwork>
        <t><strong>Envelope Notation</strong></t>
        <artwork><![CDATA[
{
    "Alice"
}
]]></artwork>
        <t><strong>Tree</strong></t>
        <artwork><![CDATA[
2bc17c65 WRAPPED
    13941b48 subj "Alice"
]]></artwork>
        <t><strong>CBOR Diagnostic Notation</strong></t>
        <artwork><![CDATA[
200(   / envelope /
   200(   / envelope /
      201("Alice")   / leaf /
   )
)
]]></artwork>
        <t><strong>CBOR Hex</strong></t>
        <artwork><![CDATA[
d8 c8                  # tag(200) envelope
   d8 c8               # tag(200) envelope
      d8 c9            # tag(201) leaf
         65            # text(5)
            416c696365 # "Alice"
]]></artwork>
      </section>
    </section>
    <section anchor="reference-implementations">
      <name>Reference Implementations</name>
      <t>This section is informative.</t>
      <t>The current reference implementations of Envelope are written in Swift <xref target="ENVELOPE-SWIFT"/> and Rust <xref target="ENVELOPE-RUST"/>.</t>
      <t>The <tt>envelope</tt> command line tool <xref target="ENVELOPE-CLI"/> is also written in Rust.</t>
    </section>
    <section anchor="security-considerations">
      <name>Security Considerations</name>
      <t>This section is informative unless noted otherwise.</t>
      <section anchor="cbor-considerations">
        <name>CBOR Considerations</name>
        <t>Generally, this document inherits the security considerations of CBOR <xref target="RFC8949"/>. Though CBOR has limited web usage, it has received strong usage in hardware, resulting in a mature specification. It also inherits the security considerations of Gordian dCBOR <xref target="DCBOR"/>.</t>
      </section>
      <section anchor="validation-requirements">
        <name>Validation Requirements</name>
        <t>Unlike HTML, Envelope is intended to be conservative in both what it encodes <em>and</em> what it accepts as valid. This means that receivers of Envelope-based documents should carefully validate them. Any deviation from the validation requirements of this specification <bcp14>MUST</bcp14> result in the rejection of the entire Envelope. Even after validation, Envelope contents should be treated with due skepticism at the application level.</t>
      </section>
      <section anchor="choice-of-sha-256-hash-primitive">
        <name>Choice of SHA-256 Hash Primitive</name>
        <t>Envelope uses the SHA-256 digest algorithm <xref target="RFC6234"/>, which is regarded as reliable and widely supported by many implementations in both software and hardware.</t>
      </section>
      <section anchor="correlated-digests">
        <name>Correlated Digests</name>
        <t>Elided Envelopes may in some cases inadvertently reveal information by transmitting digests that may be correlated to known information. In many cases this is of no consequence, but when necessary Envelopes can (when constructed) be "salted" by adding assertions that contain random data. This results in perturbing the digest tree, hence decorrelating it (after elision) from digests whose unelided contents are known.</t>
      </section>
      <section anchor="rfc-6973-considerations">
        <name>RFC 6973 Considerations</name>
        <t>"Privacy Considerations for Internet Protocols" <xref target="RFC6973"/> lists threats and guidelines related to privacy in internet protocols. Envelope is intended to help internet protocols easily adopt these considerations. It explicitly addresses the privacy-specific threats of correlation, secondary use, and disclosure by supporting the suggested guideline of Data Minimization.</t>
      </section>
      <section anchor="rfc-8280-considerations">
        <name>RFC 8280 Considerations</name>
        <t>"Research into Human Rights Protocol Considerations" <xref target="RFC8280"/> lists guidelines for human rights considerations in internet protocols. Envelope similarly adopts many of the guidelines there, improving privacy and censorship resistance through its hashed elision; and accessibility, heterogeneity support, reliability, and integrity through its fundamental data structures.</t>
      </section>
    </section>
    <section anchor="iana-considerations">
      <name>IANA Considerations</name>
      <section anchor="cbor-tags">
        <name>CBOR Tags</name>
        <t>RFC Editor: please replace RFCXXXX with the RFC number of this RFC and remove this note.</t>
        <t>IANA <xref target="IANACBORTAGS"/> has assigned the following tag:</t>
        <table>
          <name>CBOR Tag for Envelope</name>
          <thead>
            <tr>
              <th align="left">Tag</th>
              <th align="left">Data Item</th>
              <th align="left">Semantics</th>
              <th align="left">Specification</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">200</td>
              <td align="left">multiple</td>
              <td align="left">Gordian Envelope</td>
              <td align="left">[RFCXXXX]</td>
            </tr>
          </tbody>
        </table>
        <t>This document uses the tag <tt>#6.201</tt> for encapsulated dCBOR, which is defined in <xref target="DCBOR"/>.</t>
        <t>Points of contact:</t>
        <ul spacing="normal">
          <li>Christopher Allen <eref target="mailto:christophera@blockchaincommons.com">christophera@blockchaincommons.com</eref></li>
          <li>Wolf McNally <eref target="mailto:wolf@wolfmcnally.com">wolf@wolfmcnally.com</eref></li>
        </ul>
      </section>
      <section anchor="media-type">
        <name>Media Type</name>
        <t>The proposed media type <xref target="RFC6838"/> for Envelope is <tt>application/envelope+cbor</tt>. The authors understand that this will require this document to become an RFC before the media type can be registered.</t>
        <ul spacing="normal">
          <li>Type name: application</li>
          <li>Subtype name: envelope+cbor</li>
          <li>Required parameters: n/a</li>
          <li>Optional parameters: n/a</li>
          <li>Encoding considerations: binary</li>
          <li>Security considerations: See the previous section of this document</li>
          <li>Interoperability considerations: n/a</li>
          <li>Published specification: This document</li>
          <li>Applications that use this media type:  None yet, but it is expected that this format will be deployed in protocols and applications.</li>
          <li>
            <t>Additional information:
            </t>
            <ul spacing="normal">
              <li>Magic number(s): n/a</li>
              <li>File extension(s): .envelope</li>
              <li>Macintosh file type code(s): n/a</li>
            </ul>
          </li>
          <li>
            <t>Person &amp; email address to contact for further information:
            </t>
            <ul spacing="normal">
              <li>Christopher Allen <eref target="mailto:christophera@blockchaincommons.com">christophera@blockchaincommons.com</eref></li>
              <li>Wolf McNally <eref target="mailto:wolf@wolfmcnally.com">wolf@wolfmcnally.com</eref></li>
            </ul>
          </li>
          <li>Intended usage: COMMON</li>
          <li>Restrictions on usage: none</li>
          <li>
            <t>Author:
            </t>
            <ul spacing="normal">
              <li>Wolf McNally <eref target="mailto:wolf@wolfmcnally.com">wolf@wolfmcnally.com</eref></li>
            </ul>
          </li>
          <li>
            <t>Change controller:
            </t>
            <ul spacing="normal">
              <li>The IESG <eref target="mailto:iesg@ietf.org">iesg@ietf.org</eref></li>
            </ul>
          </li>
        </ul>
      </section>
    </section>
  </middle>
  <back>
    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <reference anchor="RFC8949">
          <front>
            <title>Concise Binary Object Representation (CBOR)</title>
            <author fullname="C. Bormann" initials="C." surname="Bormann"/>
            <author fullname="P. Hoffman" initials="P." surname="Hoffman"/>
            <date month="December" year="2020"/>
            <abstract>
              <t>The Concise Binary Object Representation (CBOR) is a data format whose design goals include the possibility of extremely small code size, fairly small message size, and extensibility without the need for version negotiation. These design goals make it different from earlier binary serializations such as ASN.1 and MessagePack.</t>
              <t>This document obsoletes RFC 7049, providing editorial improvements, new details, and errata fixes while keeping full compatibility with the interchange format of RFC 7049. It does not create a new version of the format.</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="94"/>
          <seriesInfo name="RFC" value="8949"/>
          <seriesInfo name="DOI" value="10.17487/RFC8949"/>
        </reference>
        <reference anchor="RFC8610">
          <front>
            <title>Concise Data Definition Language (CDDL): A Notational Convention to Express Concise Binary Object Representation (CBOR) and JSON Data Structures</title>
            <author fullname="H. Birkholz" initials="H." surname="Birkholz"/>
            <author fullname="C. Vigano" initials="C." surname="Vigano"/>
            <author fullname="C. Bormann" initials="C." surname="Bormann"/>
            <date month="June" year="2019"/>
            <abstract>
              <t>This document proposes a notational convention to express Concise Binary Object Representation (CBOR) data structures (RFC 7049). Its main goal is to provide an easy and unambiguous way to express structures for protocol messages and data formats that use CBOR or JSON.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8610"/>
          <seriesInfo name="DOI" value="10.17487/RFC8610"/>
        </reference>
        <reference anchor="RFC6838">
          <front>
            <title>Media Type Specifications and Registration Procedures</title>
            <author fullname="N. Freed" initials="N." surname="Freed"/>
            <author fullname="J. Klensin" initials="J." surname="Klensin"/>
            <author fullname="T. Hansen" initials="T." surname="Hansen"/>
            <date month="January" year="2013"/>
            <abstract>
              <t>This document defines procedures for the specification and registration of media types for use in HTTP, MIME, and other Internet protocols. This memo documents an Internet Best Current Practice.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="13"/>
          <seriesInfo name="RFC" value="6838"/>
          <seriesInfo name="DOI" value="10.17487/RFC6838"/>
        </reference>
        <reference anchor="IANACBORTAGS" target="https://www.iana.org/assignments/cbor-tags">
          <front>
            <title>Concise Binary Object Representation (CBOR) Tags</title>
            <author>
              <organization>IANA</organization>
            </author>
          </front>
        </reference>
        <reference anchor="DCBOR" target="https://www.ietf.org/archive/id/draft-mcnally-deterministic-cbor-08.html">
          <front>
            <title>Gordian dCBOR: A Deterministic CBOR Application Profile</title>
            <author>
              <organization/>
            </author>
            <date>n.d.</date>
          </front>
        </reference>
        <reference anchor="RFC6234">
          <front>
            <title>US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)</title>
            <author fullname="D. Eastlake 3rd" initials="D." surname="Eastlake 3rd"/>
            <author fullname="T. Hansen" initials="T." surname="Hansen"/>
            <date month="May" year="2011"/>
            <abstract>
              <t>Federal Information Processing Standard, FIPS</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6234"/>
          <seriesInfo name="DOI" value="10.17487/RFC6234"/>
        </reference>
        <reference anchor="ENVELOPE-SWIFT" target="https://github.com/blockchaincommons/BCSwiftEnvelope">
          <front>
            <title>Blockchain Commons Gordian Envelope for Swift</title>
            <author>
              <organization/>
            </author>
            <date>n.d.</date>
          </front>
        </reference>
        <reference anchor="ENVELOPE-RUST" target="https://crates.io/crates/bc-envelope">
          <front>
            <title>Blockchain Commons Gordian Envelope for Rust</title>
            <author>
              <organization/>
            </author>
            <date>n.d.</date>
          </front>
        </reference>
        <reference anchor="ENVELOPE-CLI" target="https://crates.io/crates/bc-envelope-cli">
          <front>
            <title>Envelope Command Line Tool (Rust)</title>
            <author>
              <organization/>
            </author>
            <date>n.d.</date>
          </front>
        </reference>
        <reference anchor="RFC2119">
          <front>
            <title>Key words for use in RFCs to Indicate Requirement Levels</title>
            <author fullname="S. Bradner" initials="S." surname="Bradner"/>
            <date month="March" year="1997"/>
            <abstract>
              <t>In many standards track documents several words are used to signify the requirements in the specification. These words are often capitalized. This document defines these words as they should be interpreted in IETF documents. This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="2119"/>
          <seriesInfo name="DOI" value="10.17487/RFC2119"/>
        </reference>
        <reference anchor="RFC8174">
          <front>
            <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
            <author fullname="B. Leiba" initials="B." surname="Leiba"/>
            <date month="May" year="2017"/>
            <abstract>
              <t>RFC 2119 specifies common key words that may be used in protocol specifications. This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the defined special meanings.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="8174"/>
          <seriesInfo name="DOI" value="10.17487/RFC8174"/>
        </reference>
      </references>
      <references>
        <name>Informative References</name>
        <reference anchor="MERKLE" target="https://en.wikipedia.org/wiki/Merkle_tree">
          <front>
            <title>Merkle Tree</title>
            <author>
              <organization/>
            </author>
            <date>n.d.</date>
          </front>
        </reference>
        <reference anchor="RFC6973">
          <front>
            <title>Privacy Considerations for Internet Protocols</title>
            <author fullname="A. Cooper" initials="A." surname="Cooper"/>
            <author fullname="H. Tschofenig" initials="H." surname="Tschofenig"/>
            <author fullname="B. Aboba" initials="B." surname="Aboba"/>
            <author fullname="J. Peterson" initials="J." surname="Peterson"/>
            <author fullname="J. Morris" initials="J." surname="Morris"/>
            <author fullname="M. Hansen" initials="M." surname="Hansen"/>
            <author fullname="R. Smith" initials="R." surname="Smith"/>
            <date month="July" year="2013"/>
            <abstract>
              <t>This document offers guidance for developing privacy considerations for inclusion in protocol specifications. It aims to make designers, implementers, and users of Internet protocols aware of privacy-related design choices. It suggests that whether any individual RFC warrants a specific privacy considerations section will depend on the document's content.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6973"/>
          <seriesInfo name="DOI" value="10.17487/RFC6973"/>
        </reference>
        <reference anchor="RFC8280">
          <front>
            <title>Research into Human Rights Protocol Considerations</title>
            <author fullname="N. ten Oever" initials="N." surname="ten Oever"/>
            <author fullname="C. Cath" initials="C." surname="Cath"/>
            <date month="October" year="2017"/>
            <abstract>
              <t>This document aims to propose guidelines for human rights considerations, similar to the work done on the guidelines for privacy considerations (RFC 6973). The other parts of this document explain the background of the guidelines and how they were developed.</t>
              <t>This document is the first milestone in a longer-term research effort. It has been reviewed by the Human Rights Protocol Considerations (HRPC) Research Group and also by individuals from outside the research group.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8280"/>
          <seriesInfo name="DOI" value="10.17487/RFC8280"/>
        </reference>
      </references>
    </references>
    <?line 852?>

<section numbered="false" anchor="acknowledgments">
      <name>Acknowledgments</name>
      <t>The authors are grateful to Carsten Bormann for his review and helpful feedback.</t>
    </section>
  </back>
  <!-- ##markdown-source:
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
dZLIhMixrUkPXVUKIlmjWJiSujdEY3KYAeoU8WEqWrdU0F6k4PruQrWVdIBo
BQYyaGIaoMS70THoNKYZRPmSn4IzkMlmGe03HR1j4y8OX6yTpd5Z6qkbGa+k
JSzELEBvAB4zbKsk0GIdxzmOP52aiGEB9rhiww81BDAb6hd0cTpF7n+8imLC
Uqodxm0JBmFFdMIjDNWz1EeDCrPMN6B5F0gxhwpoiXB0EHGbI2PHZo32yclo
SaeMgtpFXJH/lcbpbMN+OWIYqyXgxT5/fXkFPiv9r3jxkv6+OPt/r88vzk7x
78unx8+e2T883eLy6cvXz07Lv8ovT14+f3724pQ/hqei8shrPD/+S4Nx1nj5
6ur85YvjZw12vl2lhxEKyy7RFqjGwYpXySc+Pnn1n//ROQJ38v9cPDnpdjpj
8Cj5x6gzPIIfaKs0d6Pvyz+BbTceIAnCHErUoKcll4DPmDwHkc/TdSJQkQD2
Dn5BzPw2ET/4wbJz9JN+gBOuPDQ4qzwknG0/2fqYkbjj0Y5hLDYrz2uYrsJ7
/JfKb4N35+EP/4oBoGh2Rv/6k6ctUNXYLORbkidlTHsZ2xUle0Hs5m8K5U3E
65xphBmXJF03A+DtdIEZagguoBdyvvJNkiabBenLRgpedNEAlGvVCJ1c8vt0
xWoSYq6Vb+W8gX57JVNWhmtGu0Jv0QIcM+jriqKMVRZoX458bx0PC1I2NqTQ
CgejRhkH4M0C85Eg2cG4NCouXRQZtClWHhHOW5cfOPFYybRueUY6f28MW0Jo
JbWNKKTgBa0PhG9oNXTcBF5mDmoZlB16aIJjbuggFjFYkxXmOSkU0k4EeHUQ
eCsu756SnSBYn5nGe1jE28d4Hv+AOF5cmZiKAn4UQlBacdzUHnzpd0gDCREA
uSAXJCkYj0Fjqj44E6eaXi2JTo+WXMSrBYm7uqpwaG61iKYAeiBb/CFnM4Ux
AKiZjCKiYoPpaGSuKRKKvA9wj3TETCkCsJ/wCxGywwG7LWsOpg7DCOyPkrhR
DhKgZQImLSM03CBAIDH/+Mc/RBCGsWeMivhRfDdoddvtvbKgxZmAfa/+RPxI
JaZYyal4xLVd9or5B+Yh9J82JtK/1xnqwNDz6Fs9ZGcPArJ9lEHq5EdQhrLb
HzRZJLzKL3jLZG7l0d+V6HWxWhwi9L9oL+NQ/Es5bFML5W+efgsN67PxtlpD
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
L/0m07LUegAA

-->

</rfc>
