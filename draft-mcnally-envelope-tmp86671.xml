<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
]>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
<!-- generated by https://github.com/cabo/kramdown-rfc version 1.6.17 (Ruby 2.6.10) -->
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" ipr="trust200902" docName="draft-mcnally-envelope-tmp86671-latest" category="exp" submissionType="IETF" tocInclude="true" sortRefs="true" symRefs="true" version="3">
  <!-- xml2rfc v2v3 conversion 3.15.2 -->
  <front>
    <title abbrev="Envelope">The Envelope Structured Data Format</title>
    <seriesInfo name="Internet-Draft" value="draft-mcnally-envelope-tmp86671-latest"/>
    <author initials="W." surname="McNally" fullname="Wolf McNally">
      <organization>Blockchain Commons</organization>
      <address>
        <email>wolf@wolfmcnally.com</email>
      </address>
    </author>
    <author initials="C." surname="Allen" fullname="Christopher Allen">
      <organization>Blockchain Commons</organization>
      <address>
        <email>christophera@blockchaincommons.com</email>
      </address>
    </author>
    <date year="2022" month="November" day="16"/>
    <area>Applications and Real-Time</area>
    <workgroup>Network Working Group</workgroup>
    <keyword>Internet-Draft</keyword>
    <abstract>
      <t>The <tt>envelope</tt> protocol specifies a format for hierarchical binary data built on CBOR. Envelopes are designed with "smart documents" in mind, and have a number of unique features including easy representation of semantic structures like triples, built-in normalization, a built-in Merkle-like digest tree, and the ability for the holder of a document to selectively encrypt or elide specific parts of a document without invalidating the digest tree or cryptographic signatures that rely on it.</t>
    </abstract>
    <note removeInRFC="true">
      <name>Discussion Venues</name>
      <t>Source for this draft and an issue tracker can be found at
    <eref target="https://github.com/BlockchainCommons/envelope-internet-draft"/>.</t>
    </note>
  </front>
  <middle>
    <section anchor="introduction">
      <name>Introduction</name>
      <t>This document specifies the <tt>envelope</tt> protocol for hierarchical structured binary data. Envelope has a number of features that distinguish it from other forms of structured data formats, for example JSON <xref target="RFC8259"/> (envelopes are binary, not text), JSON-LD <xref target="JSONLD"/> (envelopes require no normalization because they are always constructed in canonical form), and protocol buffers <xref target="PROTOBUF"/> (envelopes allow for, but do not require a pre-existing schema.)</t>
      <t>Together these features create a smart document format with considerable privacy-enhancing, resilience, and efficiency improvements over extant structures while simultaneously maintaining it all under user control.</t>
      <section anchor="feature-digest-tree">
        <name>Feature: Digest Tree</name>
        <t>One of the key features of envelope is that it structurally provides a tree of digests for all its elements, similar to a Merkle Tree <xref target="MERKLE"/>. Additionally, each element in an envelope's hierarchy is itself an envelope, making it a recursive structure. Each element in an envelope <bcp14>MAY</bcp14> be abitrary CBOR, or one of several other types of elements that provide the envelope's structure.</t>
        <t>The creation of a digest tree allows for various efficiency improvements over hash lists and is also the fundamental basis for authentication and elision within the envelope.</t>
      </section>
      <section anchor="feature-semantic-structure">
        <name>Feature: Semantic Structure</name>
        <t>Envelope is designed to facilitate the encoding of semantic triples <xref target="TRIPLE"/>, i.e., "subject-predicate-object", e.g. "Alice knows Bob." At its top structural level, an envelope encodes a single <tt>subject</tt> and a set of zero or more <tt>assertion</tt>s about the subject, which are <tt>predicate-object</tt> pairs:</t>
        <artwork><![CDATA[
subject [
    predicate0: object0
    predicate1: object1
    ...
    predicateN: objectN
]
]]></artwork>
        <t>The simplest envelope is just a subject with no assertions, e.g., a simple plaintext string (or any other CBOR construct.) But since every element in an envelope is itelf an envelope, every element can therefore hold its own assertions. This allows any element to carry additional context, e.g. an assertion declaring the language in which a human-readable string is written. This mechanism for "assertions with assertions" provides for arbitrarily complex metadata.</t>
      </section>
      <section anchor="feature-cryptography-ready">
        <name>Feature: Cryptography Ready</name>
        <t>Because of the strictly invariant nature of the digest tree, envelopes are suitable for use in applications that employ cryptographic signatures. Such signatures in an envelope take the form of <tt>verifiedBy-Signature</tt> assertions on a <tt>subject</tt>, which is the target of the signature. Other cryptographic structures are readily supported.</t>
        <t>One of the innovative features of envelope is that these signatures will remain valid even through encryption and elision.</t>
      </section>
      <section anchor="feature-binary-efficiency-built-on-deterministic-cbor">
        <name>Feature: Binary Efficiency, Built on Deterministic CBOR</name>
        <t>Envelopes are a binary structure built on CBOR <xref target="RFC8949"/>, and <bcp14>MUST</bcp14> adhere to the requirements in section 4.2., "Deterministically Encoded CBOR". This requirement is one of several design factors ensuring that two envelopes that have the same top-level digest, and therefore contain the same digest tree, <bcp14>MUST</bcp14> represent exactly the same information. This holds true even if the two identical envelopes were assembled by different parties, at different times, and particularly in different orders.</t>
      </section>
      <section anchor="feature-digest-preserving-encryption-and-elision">
        <name>Feature: Digest-Preserving Encryption and Elision</name>
        <t>Envelope supports two digest tree-preserving transformations for any of its elements: encryption and elision.</t>
        <t>When an element is encrypted, its ciphertext remains in the envelope, and the transformation can be reversed using the symmetric key used to perform the encryption. The encrypted envelope declares the digest of its plaintext content using HMAC authentication. More sophisticated cryptographic constructs such as encryption to a set of public keys are readily supported.</t>
        <t>When an element is elided, only its digest remains in the envelope as a placeholder, and the transformation can only be reversed by subsitution with the envelope having the same root digest. Elision has several use cases:</t>
        <ul spacing="normal">
          <li>As a form of redaction, where the holder of a document reveals part of it while deliberately withholding other parts;</li>
          <li>As a form of referencing, where the digest is used as the unique identifier of a digital object that can be found outside the envelope;</li>
          <li>As a form of compression, where many identical sub-elements of an envelope (except one) are elided.</li>
        </ul>
        <t>These digest tree-preserving transformations allow the holder of an envelope-based document to selectively reveal parts of it to third parties without invalidating its signatures. It is also possible to produce proofs that one envelope (or even just the root digest of an envelope) necessarily contains another envelope by revealing only a minimum spanning set of digests.</t>
        <t>One of the most notable elements of these features is that any holder of an envelope can engage in the elision or encryption, not just the original creator.</t>
      </section>
      <section anchor="feature-privacy-protection">
        <name>Feature: Privacy Protection</name>
        <t>As per <xref target="RFC6973"/> "Privacy Considerations for Internet Protocols" S.5.2 &amp; <xref target="RFC8280"/> "Research into Human Rights Protocol Considerations" S.6.2.15 "Does the protocol provide ways for initiators to limit which information is shared with intermediaries?" we offer the following examples for improved privacy considerations through a variety of typical data-transfer methodologies, which together show a rough progression from less privacy-focused to more privacy-focused usages, all of which are possible with envelopes:</t>
        <ul spacing="normal">
          <li>Privacy-Focused Data Transfer: structured data can be publicly released; data can be authenticated through signatures and validation; data can be differently elided for different sorts of queries; data can be released through a model of progressive trust by offering less elision over time; data can be further elided by later holders based on their own risk models; data can be entirely elided so that it's only visible to queries that know to ask for the data; data can be entirely elided so that it's only visible to queries if someone provides a hash and a proof that allows them to verify the data; data can be bundled to support herd privacy.</li>
        </ul>
      </section>
      <section anchor="terminology">
        <name>Terminology</name>
        <t>The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>", "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL
NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
"<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be interpreted as
described in BCPÂ 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they
appear in all capitals, as shown here.</t>
        <t>This specification makes use of the following terminology:</t>
        <dl>
          <dt>byte</dt>
          <dd>
            <t>Used in its now-customary sense as a synonym for "octet".</t>
          </dd>
          <dt>element</dt>
          <dd>
            <t>An envelope is a tree of elements, each of which is itself an envelope.</t>
          </dd>
          <dt>image</dt>
          <dd>
            <t>The source data from which a cryptographic digest is calculated.</t>
          </dd>
        </dl>
      </section>
    </section>
    <section anchor="envelope-format-specification">
      <name>Envelope Format Specification</name>
      <t>This section is normative, and specifies the binary format of envelopes in terms of its CBOR components and their sequencing. The formal language used is the Concise Data Definition Language (CDDL) <xref target="RFC8610"/>. To be considered a well-formed envelope, a sequence of bytes <bcp14>MUST</bcp14> be well-formed deterministic CBOR <xref target="RFC8949"/> and <bcp14>MUST</bcp14> conform to the specifications in this section.</t>
      <section anchor="top-level">
        <name>Top Level</name>
        <t>An envelope is a tagged enumerated type with seven cases. Four of these cases have no children:</t>
        <ul spacing="normal">
          <li>
            <tt>leaf</tt></li>
          <li>
            <tt>known-value</tt></li>
          <li>
            <tt>encrypted</tt></li>
          <li>
            <tt>elided</tt></li>
        </ul>
        <t>Two of these cases, <tt>encrypted</tt> and <tt>elided</tt> "declare" their digest, i.e., they actually encode their digest in the envelope serialization. For all other cases, their digest is implicit in the data itself and may be computed and cached by implementations when an envelope is deserialized.</t>
        <t>The other three cases have one or more children:</t>
        <ul spacing="normal">
          <li>The <tt>node</tt> case has a child for its <tt>subject</tt> and an additional child for each of its <tt>assertion</tt>s.</li>
          <li>The <tt>wrapped-envelope</tt> case has exactly one child: the envelope that has been wrapped.</li>
          <li>The <tt>assertion</tt> case has exactly two children: the <tt>predicate</tt> and the <tt>object</tt>.</li>
        </ul>
        <sourcecode type="cddl"><![CDATA[
envelope = #6.200(
    envelope-content
)

envelope-content = (
    leaf /
    known-value /
    encrypted /
    elided /
    node /
    wrapped-envelope /
    assertion
)
]]></sourcecode>
      </section>
      <section anchor="cases-without-children">
        <name>Cases Without Children</name>
        <section anchor="leaf-case-format">
          <name>Leaf Case Format</name>
          <t>A <tt>leaf</tt> case is used when the envelope contains only user-defined CBOR content. It is tagged using #6.24, per <xref target="RFC8949"/> section 3.4.5.1, "Encoded CBOR Data Item".</t>
          <sourcecode type="cddl"><![CDATA[
leaf = #6.24(bytes)
]]></sourcecode>
        </section>
        <section anchor="known-value-case-format">
          <name>Known Value Case Format</name>
          <t>A <tt>known-value</tt> case is used to specify an unsigned integer in a namespace of well-known values. Known values are frequently used as predicates. Any envelope can be used as a predicate in an assertion, but many predicates are commonly used, e.g., <tt>verifiedBy</tt> for signatures, hence it is desirable to keep common predicates short.</t>
          <sourcecode type="cddl"><![CDATA[
known-value = #6.223(uint)
]]></sourcecode>
        </section>
        <section anchor="encrypted-case-format">
          <name>Encrypted Case Format</name>
          <t>An <tt>encrypted</tt> case is used for an envelope that has been encrypted using an Authenticated Encryption with Associated Data (AEAD), and where the digest of the plaintext is declared by the encrypted structure's Additional Authenticated Data (AAD) field. This subsection specifies the construct used in the current reference implementation and is informative.</t>
          <sourcecode type="cddl"><![CDATA[
encrypted = crypto-msg
]]></sourcecode>
          <t>For <tt>crypto-msg</tt>, the reference implementation <xref target="ENVELOPE-REFIMPL"/> uses the definition in "UR Type Definition for Secure Messages" <xref target="CRYPTO-MSG"/> and we repeat the salient specification here. This format specifies the use of "ChaCha20 and Poly1305 for IETF Protocols" as described in <xref target="RFC7539"/>. When used with envelopes, the <tt>crypto-msg</tt> construct <tt>aad</tt> (additional authenticated data) field contains the <tt>digest</tt> of the plaintext, authenticating the declared digest using the Poly1305 HMAC.</t>
          <sourcecode type="cddl"><![CDATA[
crypto-msg = #6.201([ ciphertext, nonce, auth, ? aad ])

ciphertext = bytes       ; encrypted using ChaCha20
aad = digest             ; Additional Authenticated Data
nonce = bytes .size 12   ; Random, generated at encryption-time
auth = bytes .size 16    ; Authentication tag created by Poly1305
]]></sourcecode>
        </section>
        <section anchor="elided-case-format">
          <name>Elided Case Format</name>
          <t>An <tt>elided</tt> case is used as a placeholder for an element that has been elided and its digest, produced by a cryptographic hash algorithm is left as a placeholder. This subsection specifies the construct used in the current reference implementation and is informative.</t>
          <sourcecode type="cddl"><![CDATA[
elided = digest
]]></sourcecode>
          <t>For <tt>digest</tt>, the reference implementation <xref target="ENVELOPE-REFIMPL"/> uses of the BLAKE3 cryptographic hash function <xref target="BLAKE3"/> to generate a 32 byte digest.</t>
          <sourcecode type="cddl"><![CDATA[
digest = #6.203(blake3-digest)

blake3-digest = bytes .size 32
]]></sourcecode>
        </section>
      </section>
      <section anchor="cases-with-children">
        <name>Cases With Children</name>
        <section anchor="node-case-format">
          <name>Node Case Format</name>
          <t>A <tt>node</tt> case is encoded as a CBOR array, and <bcp14>MUST</bcp14> be used when one or more assertions are present on the envelope. It <bcp14>MUST NOT</bcp14> be present when there is not at least one assertion. The first element of the array is the envelope's <tt>subject</tt>, Followed by one or more <tt>assertion-element</tt>s, each of which <bcp14>MUST</bcp14> be an <tt>assertion</tt>, or the <tt>encrypted</tt> or <tt>elided</tt> transformation of that assertion. The assertion elements <bcp14>MUST</bcp14> appear in ascending lexicographic order by their digest. The array <bcp14>MUST NOT</bcp14> contain any assertion elements with identical digests.</t>
          <sourcecode type="cddl"><![CDATA[
node = [envelope-content, + assertion-element]

assertion-element = ( assertion / encrypted / elided )
]]></sourcecode>
        </section>
        <section anchor="wrapped-envelope-case-format">
          <name>Wrapped Envelope Case Format</name>
          <t>A <tt>wrapped-envelope</tt> case is used where an envelope including all its assertions should be treated as a single element, e.g. for the purpose of signing.</t>
          <sourcecode type="cddl"><![CDATA[
wrapped-envelope = #6.224(envelope-content)
]]></sourcecode>
        </section>
        <section anchor="assertion-case-format">
          <name>Assertion Case Format</name>
          <t>An <tt>assertion</tt> case is used for each of the assertions in an envelope. It is encoded as a CBOR array with exactly two elements in order:</t>
          <ol spacing="normal" type="1"><li>the envelope representing the predicate of the assertion, followed by</li>
            <li>the envelope representing the object of the assertion.</li>
          </ol>
          <sourcecode type="cddl"><![CDATA[
assertion = #6.221([predicate-envelope, object-envelope])
predicate-envelope = envelope
object-envelope = envelope
]]></sourcecode>
        </section>
      </section>
    </section>
    <section anchor="computing-the-digest-tree">
      <name>Computing the Digest Tree</name>
      <t>This section specifies how the digests for each of the envelope cases are computed. The minimum size of the digest and order of operations specified is normative, but the specific cryptographic hash algorithm used by the reference implementation <xref target="BLAKE3"/> is informative. When implementing using BLAKE3, the examples in this section may be used as test vectors.</t>
      <t>Each of the seven enumerated envelope cases produces an image which is used as input to a cryptographic hash function to produce a digest of its contents.</t>
      <t>The overall digest of an envelope is the digest of its specific case.</t>
      <t>In this and subsequenct sections:</t>
      <ul spacing="normal">
        <li>
          <tt>digest(image)</tt> is the BLAKE3 hash function that produces a 32-byte digest.</li>
        <li>The <tt>.digest</tt> attribute is the digest of the named element computed as specified herein.</li>
        <li>The <tt>||</tt> operator represents contactenation of byte sequences.</li>
      </ul>
      <section anchor="leaf-case-digest-calculation">
        <name>Leaf Case Digest Calculation</name>
        <t>The <tt>leaf</tt> case consists of any CBOR object. Tagging the leaf CBOR is <bcp14>RECOMMENDED</bcp14>, especially for compound structures with a specified layout. The envelope image is the CBOR serialization of that object:</t>
        <artwork><![CDATA[
digest(cbor)
]]></artwork>
        <section anchor="example">
          <name>Example</name>
          <t>The CBOR serialization of the plaintext string <tt>"Hello"</tt> (not including the quotes) is <tt>6548656C6C6F</tt>. The following command line calculates the BLAKE3 sum of this sequence:</t>
          <artwork><![CDATA[
$ echo "6548656C6C6F" | xxd -r -p | b3sum --no-names
bd6c78899fc1f22c667cfe6893aa2414f8124f25ae6ea80a1a66c2d1d6b455ea
]]></artwork>
          <t>Using the envelope command line tool <xref target="ENVELOPE-CLI"/>, we create an envelope with this string as the subject and display the envelope's digest. The digest below matches the one above.</t>
          <artwork><![CDATA[
$ envelope subject "Hello" | envelope digest --hex
bd6c78899fc1f22c667cfe6893aa2414f8124f25ae6ea80a1a66c2d1d6b455ea
]]></artwork>
        </section>
      </section>
      <section anchor="known-value-case-digest-calculation">
        <name>Known Value Case Digest Calculation</name>
        <t>The envelope image of the <tt>known-value</tt> case is the CBOR serialization of the unsigned integer value of the value tagged with #6.223, as specified in the Known Value Case Format section above.</t>
        <artwork><![CDATA[
digest(#6.223(uint))
]]></artwork>
        <section anchor="example-1">
          <name>Example</name>
          <t>The known value <tt>verifiedBy</tt> in CBOR diagnostic notation is <tt>223(3)</tt>, which in hex is <tt>D8DF03</tt>. The BLAKE3 sum of this sequence is:</t>
          <artwork><![CDATA[
$ echo "D8DF03" | xxd -r -p | b3sum --no-names
d59f8c0ffd798eac7602d1dfb15c457d8e51c3ce34d499e5d2a4fbd2cfe3773f
]]></artwork>
          <t>Using the envelope command line tool <xref target="ENVELOPE-CLI"/>, we create an envelope with this known value as the subject and display the envelope's digest. The digest below matches the one above.</t>
          <artwork><![CDATA[
$ envelope subject --known verifiedBy | envelope digest --hex
d59f8c0ffd798eac7602d1dfb15c457d8e51c3ce34d499e5d2a4fbd2cfe3773f
]]></artwork>
        </section>
      </section>
      <section anchor="encrypted-case-digest-calculation">
        <name>Encrypted Case Digest Calculation</name>
        <t>The <tt>encrypted</tt> case declares its digest to be the digest of plaintext before encryption. The declaration is made using an HMAC, and when decrypting an element the implementation <bcp14>MUST</bcp14> compare the digest of the decrypted element to the declared digest and flag an error if they do not match.</t>
        <section anchor="example-2">
          <name>Example</name>
          <t>If we create the envelope from the leaf example above, encrypt it, and then request its digest:</t>
          <artwork><![CDATA[
$ KEY=`envelope generate key`
$ envelope subject "Hello" | envelope encrypt --key $KEY | envelope digest --hex
bd6c78899fc1f22c667cfe6893aa2414f8124f25ae6ea80a1a66c2d1d6b455ea
]]></artwork>
          <t>...we see that its digest is the same as its plaintext form:</t>
          <artwork><![CDATA[
$ envelope subject "Hello" | envelope digest --hex
bd6c78899fc1f22c667cfe6893aa2414f8124f25ae6ea80a1a66c2d1d6b455ea
]]></artwork>
        </section>
      </section>
      <section anchor="elided-case-digest-calculation">
        <name>Elided Case Digest Calculation</name>
        <t>The <tt>elided</tt> case declares its digest to be the digest of the envelope for which it is a placeholder.</t>
        <section anchor="example-3">
          <name>Example</name>
          <t>If we create the envelope from the leaf example above, elide it, and then request its digest:</t>
          <artwork><![CDATA[
$ envelope subject "Hello" | envelope elide | envelope digest --hex
bd6c78899fc1f22c667cfe6893aa2414f8124f25ae6ea80a1a66c2d1d6b455ea
]]></artwork>
          <t>...we see that its digest is the same as its unelided form:</t>
          <artwork><![CDATA[
$ envelope subject "Hello" | envelope digest --hex
bd6c78899fc1f22c667cfe6893aa2414f8124f25ae6ea80a1a66c2d1d6b455ea
]]></artwork>
        </section>
      </section>
      <section anchor="node-case-digest-calculation">
        <name>Node Case Digest Calculation</name>
        <t>The envelope image of the <tt>node</tt> case is the concatenation of the digest of its <tt>subject</tt> and the digests of its assertions sorted in ascending lexicographic order.</t>
        <t>With a <tt>node</tt> case, there <bcp14>MUST</bcp14> always be at least one assertion.</t>
        <artwork><![CDATA[
digest(subject.digest || assertion-0.digest || assertion-1.digest || ... || assertion-n.digest)
]]></artwork>
        <section anchor="example-4">
          <name>Example</name>
          <t>We create four separate envelopes and display their digests:</t>
          <artwork><![CDATA[
$ SUBJECT=`envelope subject "Alice"`
$ envelope digest --hex $SUBJECT
278403504ad3a9a9c24c1b35a3673eee165a5d523f8d2a5cf5ce6dd25a37f110

$ ASSERTION_0=`envelope subject assertion "knows" "Bob"`
$ envelope digest --hex $ASSERTION_0
55560bdf060f1220199c87e84e29cecef96ef811de4f399dab2fde9425d0d418

$ ASSERTION_1=`envelope subject assertion "knows" "Carol"`
$ envelope digest --hex $ASSERTION_1
71a3069088c61c928f54ec50859f3f09b9318e9ca6734e6a3b5f77aa3159a711

$ ASSERTION_2=`envelope subject assertion "knows" "Edward"`
$ envelope digest --hex $ASSERTION_2
1e0b049b8d2b21d4bb32f90b4a9e6b5031526f868da303268a9c1c75c0082446
]]></artwork>
          <t>We combine the envelopes into a single envelope with three assertions:</t>
          <artwork><![CDATA[
$ ENVELOPE=`envelope assertion add envelope $ASSERTION_0 $SUBJECT | \
    envelope assertion add envelope $ASSERTION_1 | \
    envelope assertion add envelope $ASSERTION_2`

$ envelope $ENVELOPE
"Alice" [
    "knows": "Bob"
    "knows": "Carol"
    "knows": "Edward"
]

$ envelope digest --hex $ENVELOPE
0abac60ae3a45a8a7b448b309cca30bdd747f42f508a9a97ea64d657d1f7ea81
]]></artwork>
          <t>Note that in the envelope notation representation above, the assertions are sorted alphabetically, with <tt>"knows": "Edward"</tt> coming last. But internally, the three assertions are ordered by digest in ascending lexicographic order, with "Edward" coming first because its digest starting with <tt>1e0b049b</tt> is the lowest, as in the tree formatted display below:</t>
          <artwork><![CDATA[
$ envelope --tree $ENVELOPE
0abac60a NODE
    27840350 subj "Alice"
    1e0b049b ASSERTION
        7092d620 pred "knows"
        d5a375ff obj "Edward"
    55560bdf ASSERTION
        7092d620 pred "knows"
        9a771715 obj "Bob"
    71a30690 ASSERTION
        7092d620 pred "knows"
        ad2c454b obj "Carol"
]]></artwork>
          <t>To replicate this, we make a list of digests, starting with the subject, and then each assertion's digest in ascending lexicographic order:</t>
          <artwork><![CDATA[
278403504ad3a9a9c24c1b35a3673eee165a5d523f8d2a5cf5ce6dd25a37f110
1e0b049b8d2b21d4bb32f90b4a9e6b5031526f868da303268a9c1c75c0082446
55560bdf060f1220199c87e84e29cecef96ef811de4f399dab2fde9425d0d418
71a3069088c61c928f54ec50859f3f09b9318e9ca6734e6a3b5f77aa3159a711
]]></artwork>
          <t>We then calculate the BLAKE3 hash of the concatenation of these four digests, and note that this is the same digest as the composite envelope's digest:</t>
          <artwork><![CDATA[
echo "278403504ad3a9a9c24c1b35a3673eee165a5d523f8d2a5cf5ce6dd25a37f1101e0b049b8d2b21d4bb32f90b4a9e6b5031526f868da303268a9c1c75c008244655560bdf060f1220199c87e84e29cecef96ef811de4f399dab2fde9425d0d41871a3069088c61c928f54ec50859f3f09b9318e9ca6734e6a3b5f77aa3159a711" | xxd -r -p | b3sum --no-names
0abac60ae3a45a8a7b448b309cca30bdd747f42f508a9a97ea64d657d1f7ea81

$ envelope digest --hex $ENVELOPE
0abac60ae3a45a8a7b448b309cca30bdd747f42f508a9a97ea64d657d1f7ea81
]]></artwork>
        </section>
      </section>
      <section anchor="wrapped-envelope-case-digest-calculation">
        <name>Wrapped Envelope Case Digest Calculation</name>
        <t>The envelope image of the <tt>wrapped-envelope</tt> case is the digest of the wrapped envelope:</t>
        <artwork><![CDATA[
digest(envelope.digest)
]]></artwork>
        <section anchor="example-5">
          <name>Example</name>
          <t>As above, we note the digest of a leaf envelope is the digest of its CBOR:</t>
          <artwork><![CDATA[
$ envelope subject "Hello" | envelope digest --hex
bd6c78899fc1f22c667cfe6893aa2414f8124f25ae6ea80a1a66c2d1d6b455ea

$ echo "6548656C6C6F" | xxd -r -p | b3sum --no-names
bd6c78899fc1f22c667cfe6893aa2414f8124f25ae6ea80a1a66c2d1d6b455ea
]]></artwork>
          <t>Now we note that the digest of a wrapped envelope is the digest of the wrapped envelope's digest:</t>
          <artwork><![CDATA[
$ envelope subject "Hello" | envelope subject --wrapped | envelope digest --hex
55d4e04399c54bec23346ebf612bf237e659a72e34df14420e18e0290f28c31b

$ echo "bd6c78899fc1f22c667cfe6893aa2414f8124f25ae6ea80a1a66c2d1d6b455ea" | xxd -r -p | b3sum --no-names
55d4e04399c54bec23346ebf612bf237e659a72e34df14420e18e0290f28c31b
]]></artwork>
        </section>
      </section>
      <section anchor="assertion-case-digest-calculation">
        <name>Assertion Case Digest Calculation</name>
        <t>The envelope image of the <tt>assertion</tt> case is the concatenation of the digests of the assertion's predicate and object in that order:</t>
        <artwork><![CDATA[
digest(predicate.digest || object.digest)
]]></artwork>
        <section anchor="example-6">
          <name>Example</name>
          <t>We create an assertion from two separate envelopes and display their digests:</t>
          <artwork><![CDATA[
$ PREDICATE=`envelope subject "knows"`
$ envelope digest --hex $PREDICATE
7092d62002c3d0f3c889058092e6915bad908f03263c2dc91bfea6fd8ee62fab

$ OBJECT=`envelope subject "Bob"`
$ envelope digest --hex $OBJECT
9a7717153d7a31b0390011413bdf9500ff4d8870ccf102ae31eaa165ab25df1a

$ ASSERTION=`envelope subject assertion "knows" "Bob"`
$ envelope digest --hex $ASSERTION
55560bdf060f1220199c87e84e29cecef96ef811de4f399dab2fde9425d0d418
]]></artwork>
          <t>To replicate this, we make a list of the predicate digest and the object digest, in that order:</t>
          <artwork><![CDATA[
7092d62002c3d0f3c889058092e6915bad908f03263c2dc91bfea6fd8ee62fab
9a7717153d7a31b0390011413bdf9500ff4d8870ccf102ae31eaa165ab25df1a
]]></artwork>
          <t>We then calculate the BLAKE3 hash of the concatenation of these two digests, and note that this is the same digest as the composite envelope's digest:</t>
          <artwork><![CDATA[
echo "7092d62002c3d0f3c889058092e6915bad908f03263c2dc91bfea6fd8ee62fab9a7717153d7a31b0390011413bdf9500ff4d8870ccf102ae31eaa165ab25df1a" | xxd -r -p | b3sum --no-names
55560bdf060f1220199c87e84e29cecef96ef811de4f399dab2fde9425d0d418

$ envelope digest --hex $ASSERTION
55560bdf060f1220199c87e84e29cecef96ef811de4f399dab2fde9425d0d418
]]></artwork>
        </section>
      </section>
    </section>
    <section anchor="envelope-hierarchy">
      <name>Envelope Hierarchy</name>
      <t>This section is informative, and describes envelopes from the perspective of their hierachical structure and the various ways they can be formatted.</t>
      <t>An envelope consists of a <tt>subject</tt> and one or more <tt>predicate-object</tt> pairs called <tt>assertions</tt>:</t>
      <artwork><![CDATA[
subject [
    predicate0: object0
    predicate1: object1
    ...
    predicateN: objectN
]
]]></artwork>
      <t>A concrete example of this might be:</t>
      <artwork><![CDATA[
"Alice" [
    "knows": "Bob"
    "knows": "Carol"
    "knows": "Edward"
]
]]></artwork>
      <t>In the diagram above, there are five distinct "positions" of elements, each of which is itself an envelope and which therefore produces its own digest:</t>
      <ol spacing="normal" type="1"><li>envelope</li>
        <li>subject</li>
        <li>assertion</li>
        <li>predicate</li>
        <li>object</li>
      </ol>
      <t>The examples above are printed in "envelope notation," which is designed to make the semantic content of envelopes human-readable, but it doesn't show the actual digests associated with each of the positions. To see the structure more completely, we can display every element of the envelope in Tree Notation:</t>
      <artwork><![CDATA[
0abac60a NODE
    27840350 subj "Alice"
    1e0b049b ASSERTION
        7092d620 pred "knows"
        d5a375ff obj "Edward"
    55560bdf ASSERTION
        7092d620 pred "knows"
        9a771715 obj "Bob"
    71a30690 ASSERTION
        7092d620 pred "knows"
        ad2c454b obj "Carol"
]]></artwork>
      <t>We can also show the digest tree graphically using Mermaid <xref target="MERMAID"/>:</t>
      <artwork type="svg" src="images/svg-validated/example.svg"/>
      <t>For easy recognition, envelope trees and Mermaid diagrams only show the first four bytes of each digest, but internally all digests are 32 bytes.</t>
      <t>From the above envelope and its tree, we make the following observations:</t>
      <ul spacing="normal">
        <li>The envelope is a <tt>node</tt> case, which holds the overall envelope digest.</li>
        <li>The subject "Alice" has its own digest.</li>
        <li>Each of the three assertions have their own digests</li>
        <li>The predicate and object of each assertion each have their own digests.</li>
        <li>The assertions appear in the structure in ascending lexicographic order by digest, which is distinct from envelope notation where they appear sorted alphabeticaly.</li>
      </ul>
      <t>The following subsections present each of the seven enumerated envelope cases in five different output formats:</t>
      <ul spacing="normal">
        <li>Envelope Notation</li>
        <li>Envelope Tree</li>
        <li>Mermaid</li>
        <li>CBOR Diagnostic Notation</li>
        <li>CBOR hex</li>
      </ul>
      <t>These examples may be used as test vectors. In addition, each subsection starts with the envelope command line <xref target="ENVELOPE-CLI"/> needed to generate the envelope being formatted.</t>
      <section anchor="leaf-case">
        <name>Leaf Case</name>
        <section anchor="envelope-cli-command-line">
          <name>Envelope CLI Command Line</name>
          <artwork><![CDATA[
envelope subject "Alice"
]]></artwork>
        </section>
        <section anchor="envelope-notation">
          <name>Envelope Notation</name>
          <artwork><![CDATA[
"Alice"
]]></artwork>
        </section>
        <section anchor="tree">
          <name>Tree</name>
          <artwork><![CDATA[
27840350 "Alice"
]]></artwork>
        </section>
        <section anchor="mermaid">
          <name>Mermaid</name>
          <artwork type="svg" src="images/svg-validated/leaf_case.svg"/>
        </section>
        <section anchor="cbor-diagnostic-notation">
          <name>CBOR Diagnostic Notation</name>
          <artwork><![CDATA[
200(   ; envelope
   24("Alice")   ; leaf
)
]]></artwork>
        </section>
        <section anchor="cbor-hex">
          <name>CBOR Hex</name>
          <artwork><![CDATA[
d8c8d81865416c696365
]]></artwork>
        </section>
      </section>
      <section anchor="known-value-case">
        <name>Known Value Case</name>
        <section anchor="envelope-cli-command-line-1">
          <name>Envelope CLI Command Line</name>
          <artwork><![CDATA[
envelope subject --known verifiedBy
]]></artwork>
        </section>
        <section anchor="envelope-notation-1">
          <name>Envelope Notation</name>
          <artwork><![CDATA[
verifiedBy
]]></artwork>
        </section>
        <section anchor="tree-1">
          <name>Tree</name>
          <artwork><![CDATA[
d59f8c0f verifiedBy
]]></artwork>
        </section>
        <section anchor="mermaid-1">
          <name>Mermaid</name>
          <artwork type="svg" src="images/svg-validated/known_value_case.svg"/>
        </section>
        <section anchor="cbor-diagnostic-notation-1">
          <name>CBOR Diagnostic Notation</name>
          <artwork><![CDATA[
200(   ; envelope
   223(3)   ; known-value
)
]]></artwork>
        </section>
        <section anchor="cbor-hex-1">
          <name>CBOR Hex</name>
          <artwork><![CDATA[
d8c8d8df03
]]></artwork>
        </section>
      </section>
      <section anchor="encrypted-case">
        <name>Encrypted Case</name>
        <section anchor="envelope-cli-command-line-2">
          <name>Envelope CLI Command Line</name>
          <artwork><![CDATA[
envelope subject "Alice" | envelope encrypt --key `envelope generate key`
]]></artwork>
        </section>
        <section anchor="envelope-notation-2">
          <name>Envelope Notation</name>
          <artwork><![CDATA[
ENCRYPTED
]]></artwork>
        </section>
        <section anchor="tree-2">
          <name>Tree</name>
          <artwork><![CDATA[
27840350 ENCRYPTED
]]></artwork>
        </section>
        <section anchor="mermaid-2">
          <name>Mermaid</name>
          <artwork type="svg" src="images/svg-validated/encrypted_case.svg"/>
        </section>
        <section anchor="cbor-diagnostic-notation-2">
          <name>CBOR Diagnostic Notation</name>
          <artwork><![CDATA[
200(   ; envelope
   201(   ; crypto-msg
      [
         h'6bfa027df241def0',
         h'5520ca6d9d798ffd32d075c4',
         h'd4b43d97a37eb280fdd89cf152ccf57d',
         h'd8cb5820278403504ad3a9a9c24c1b35a3673eee165a5d523f8d2a5cf5ce6dd25a37f110'
      ]
   )
)
]]></artwork>
        </section>
        <section anchor="cbor-hex-2">
          <name>CBOR Hex</name>
          <artwork><![CDATA[
d8c8d8c984486bfa027df241def04c5520ca6d9d798ffd32d075c450d4b43d97a37eb280fdd89cf152ccf57d5824d8cb5820278403504ad3a9a9c24c1b35a3673eee165a5d523f8d2a5cf5ce6dd25a37f110
]]></artwork>
        </section>
      </section>
      <section anchor="elided-case">
        <name>Elided Case</name>
        <section anchor="envelope-cli-command-line-3">
          <name>Envelope CLI Command Line</name>
          <artwork><![CDATA[
envelope subject "Alice" | envelope elide
]]></artwork>
        </section>
        <section anchor="envelope-notation-3">
          <name>Envelope Notation</name>
          <artwork><![CDATA[
ELIDED
]]></artwork>
        </section>
        <section anchor="tree-3">
          <name>Tree</name>
          <artwork><![CDATA[
27840350 ELIDED
]]></artwork>
        </section>
        <section anchor="mermaid-3">
          <name>Mermaid</name>
          <artwork type="svg" src="images/svg-validated/elided_case.svg"/>
        </section>
        <section anchor="cbor-diagnostic-notation-3">
          <name>CBOR Diagnostic Notation</name>
          <artwork><![CDATA[
200(   ; envelope
   203(   ; crypto-digest
      h'278403504ad3a9a9c24c1b35a3673eee165a5d523f8d2a5cf5ce6dd25a37f110'
   )
)
]]></artwork>
        </section>
        <section anchor="cbor-hex-3">
          <name>CBOR Hex</name>
          <artwork><![CDATA[
d8c8d8cb5820278403504ad3a9a9c24c1b35a3673eee165a5d523f8d2a5cf5ce6dd25a37f110
]]></artwork>
        </section>
      </section>
      <section anchor="node-case">
        <name>Node Case</name>
        <section anchor="envelope-cli-command-line-4">
          <name>Envelope CLI Command Line</name>
          <artwork><![CDATA[
envelope subject "Alice" | envelope assertion "knows" "Bob"
]]></artwork>
        </section>
        <section anchor="envelope-notation-4">
          <name>Envelope Notation</name>
          <artwork><![CDATA[
"Alice" [
    "knows": "Bob"
]
]]></artwork>
        </section>
        <section anchor="tree-4">
          <name>Tree</name>
          <artwork><![CDATA[
e54d6fd3 NODE
    27840350 subj "Alice"
    55560bdf ASSERTION
        7092d620 pred "knows"
        9a771715 obj "Bob"
]]></artwork>
        </section>
        <section anchor="mermaid-4">
          <name>Mermaid</name>
          <artwork type="svg" src="images/svg-validated/node_case.svg"/>
        </section>
        <section anchor="cbor-diagnostic-notation-4">
          <name>CBOR Diagnostic Notation</name>
          <artwork><![CDATA[
200(   ; envelope
   [
      200(   ; envelope
         24("Alice")   ; leaf
      ),
      200(   ; envelope
         221(   ; assertion
            [
               200(   ; envelope
                  24("knows")   ; leaf
               ),
               200(   ; envelope
                  24("Bob")   ; leaf
               )
            ]
         )
      )
   ]
)
]]></artwork>
        </section>
        <section anchor="cbor-hex-4">
          <name>CBOR Hex</name>
          <artwork><![CDATA[
d8c882d8c8d81865416c696365d8c8d8dd82d8c8d818656b6e6f7773d8c8d81863426f62
]]></artwork>
        </section>
      </section>
      <section anchor="wrapped-envelope-case">
        <name>Wrapped Envelope Case</name>
        <section anchor="envelope-cli-command-line-5">
          <name>Envelope CLI Command Line</name>
          <artwork><![CDATA[
envelope subject "Alice" | envelope subject --wrapped
]]></artwork>
        </section>
        <section anchor="envelope-notation-5">
          <name>Envelope Notation</name>
          <artwork><![CDATA[
{
    "Alice"
}
]]></artwork>
        </section>
        <section anchor="tree-5">
          <name>Tree</name>
          <artwork><![CDATA[
aaed47e8 WRAPPED
    27840350 subj "Alice"
]]></artwork>
        </section>
        <section anchor="mermaid-5">
          <name>Mermaid</name>
          <artwork type="svg" src="images/svg-validated/wrapped_envelope_case.svg"/>
        </section>
        <section anchor="cbor-diagnostic-notation-5">
          <name>CBOR Diagnostic Notation</name>
          <artwork><![CDATA[
200(   ; envelope
   224(   ; wrapped-envelope
      24("Alice")   ; leaf
   )
)
]]></artwork>
        </section>
        <section anchor="cbor-hex-5">
          <name>CBOR Hex</name>
          <artwork><![CDATA[
d8c8d8e0d81865416c696365
]]></artwork>
        </section>
      </section>
      <section anchor="assertion-case">
        <name>Assertion Case</name>
        <section anchor="envelope-cli-command-line-6">
          <name>Envelope CLI Command Line</name>
          <artwork><![CDATA[
envelope subject assertion "knows" "Bob"
]]></artwork>
        </section>
        <section anchor="envelope-notation-6">
          <name>Envelope Notation</name>
          <artwork><![CDATA[
"knows": "Bob"
]]></artwork>
        </section>
        <section anchor="tree-6">
          <name>Tree</name>
          <artwork><![CDATA[
55560bdf ASSERTION
    7092d620 pred "knows"
    9a771715 obj "Bob"
]]></artwork>
        </section>
        <section anchor="mermaid-6">
          <name>Mermaid</name>
          <artwork type="svg" src="images/svg-validated/assertion_case.svg"/>
        </section>
        <section anchor="cbor-diagnostic-notation-6">
          <name>CBOR Diagnostic Notation</name>
          <artwork><![CDATA[
200(   ; envelope
   221(   ; assertion
      [
         200(   ; envelope
            24("knows")   ; leaf
         ),
         200(   ; envelope
            24("Bob")   ; leaf
         )
      ]
   )
)
]]></artwork>
        </section>
        <section anchor="cbor-hex-6">
          <name>CBOR Hex</name>
          <artwork><![CDATA[
d8c8d8dd82d8c8d818656b6e6f7773d8c8d81863426f62
]]></artwork>
        </section>
      </section>
    </section>
    <section anchor="known-values">
      <name>Known Values</name>
      <t>This section is informative.</t>
      <t>Known values are a specific case of envelope that defines a namespace consisting of single unsigned integers. The expectation is that the most common and widely useful predicates will be assigned in this namespace, but known values may be used in any position in an envelope.</t>
      <t>Most of the examples in this document use UTF-8 strings as predicates, but in real-world applications the same predicate may be used many times in a document and across a body of knowledge. Since the size of an envelope is proportionate to the size of its content, a predicate made using a string like a human-readable sentence or a URL could take up a great deal of space in a typical envelope. Even emplacing the digest of a known structure takes 32 bytes. Known values provide a way to compactly represent predicates and other common values in as few as three bytes.</t>
      <t>Other CBOR tags can be used to define completely separate namespaces if desired, but the reference implementation <xref target="ENVELOPE-REFIMPL"/> and its tools <xref target="ENVELOPE-CLI"/> recognize specific known values and their human-readable names.</t>
      <t>Custom ontologies such as Web Ontology Language <xref target="OWL"/> or Friend of a Friend <xref target="FOAF"/> may someday be represented as ranges of integers in this known space, or be defined in their own namespaces.</t>
      <t>A specification for a standard minimal ontology of known values is TBD.</t>
      <t>The following table lists all the known values currently defined in the reference implementation <xref target="ENVELOPE-REFIMPL"/>. This list is currently informative, but all these known values have been used in the reference implementation for various examples and test vectors.</t>
      <t>Note that a work-in-progress specification for remote procedure calls using envelope has been assigned a namespace starting at 100.</t>
      <table>
        <thead>
          <tr>
            <th align="left">Value</th>
            <th align="left">Name</th>
            <th align="left">Used as</th>
            <th align="left">Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td align="left">1</td>
            <td align="left">
              <tt>id</tt></td>
            <td align="left">predicate</td>
            <td align="left">A domain-unique identifier of some kind.</td>
          </tr>
          <tr>
            <td align="left">2</td>
            <td align="left">
              <tt>isA</tt></td>
            <td align="left">predicate</td>
            <td align="left">A domain-specific type identifier.</td>
          </tr>
          <tr>
            <td align="left">3</td>
            <td align="left">
              <tt>verifiedBy</tt></td>
            <td align="left">predicate</td>
            <td align="left">A signature on the digest of the subject, verifiable with the signer's public key.</td>
          </tr>
          <tr>
            <td align="left">4</td>
            <td align="left">
              <tt>note</tt></td>
            <td align="left">predicate</td>
            <td align="left">A human-readable informative note.</td>
          </tr>
          <tr>
            <td align="left">5</td>
            <td align="left">
              <tt>hasRecipient</tt></td>
            <td align="left">predicate</td>
            <td align="left">A sealed message encrypting to a specific recipient the ephemeral encryption key that was used to encrypt the subject.</td>
          </tr>
          <tr>
            <td align="left">6</td>
            <td align="left">
              <tt>sskrShare</tt></td>
            <td align="left">predicate</td>
            <td align="left">A single SSKR <xref target="SSKR"/> share of the emphemeral encryption key that was used to encrypt the subject.</td>
          </tr>
          <tr>
            <td align="left">7</td>
            <td align="left">
              <tt>controller</tt></td>
            <td align="left">predicate</td>
            <td align="left">A domain-unique identifier of the party that controls the contents of this document.</td>
          </tr>
          <tr>
            <td align="left">8</td>
            <td align="left">
              <tt>publicKeys</tt></td>
            <td align="left">predicate</td>
            <td align="left">A "public key base" consisting of the information needed to encrypt messages to a party or verify messages signed by them.</td>
          </tr>
          <tr>
            <td align="left">9</td>
            <td align="left">
              <tt>dereferenceVia</tt></td>
            <td align="left">predicate</td>
            <td align="left">A domain-unique Pointer such as a URL indicating from where the elided envelope subject can be recovered.</td>
          </tr>
          <tr>
            <td align="left">10</td>
            <td align="left">
              <tt>entity</tt></td>
            <td align="left">predicate</td>
            <td align="left">A document representing an entity of interest in the current context.</td>
          </tr>
          <tr>
            <td align="left">11</td>
            <td align="left">
              <tt>hasName</tt></td>
            <td align="left">predicate</td>
            <td align="left">The human-readable name of the subject.</td>
          </tr>
          <tr>
            <td align="left">12</td>
            <td align="left">
              <tt>language</tt></td>
            <td align="left">predicate</td>
            <td align="left">The ISO 639 <xref target="ISO639"/> code for the human natural language used to write the subject.</td>
          </tr>
          <tr>
            <td align="left">13</td>
            <td align="left">
              <tt>issuer</tt></td>
            <td align="left">predicate</td>
            <td align="left">A domain-unique identifier of the document's issuing entity.</td>
          </tr>
          <tr>
            <td align="left">14</td>
            <td align="left">
              <tt>holder</tt></td>
            <td align="left">predicate</td>
            <td align="left">A domain-unique identifier of the document's holder, i.e., the entity to which the document pertains.</td>
          </tr>
          <tr>
            <td align="left">15</td>
            <td align="left">
              <tt>salt</tt></td>
            <td align="left">predicate</td>
            <td align="left">A block of random data used to deliberately perturb the digest tree for the purpose of decorrelation.</td>
          </tr>
          <tr>
            <td align="left">16</td>
            <td align="left">
              <tt>date</tt></td>
            <td align="left">predicate</td>
            <td align="left">A timestamp, e.g., the time at which a remote procedure call request was signed.</td>
          </tr>
          <tr>
            <td align="left">100</td>
            <td align="left">
              <tt>body</tt></td>
            <td align="left">predicate</td>
            <td align="left">RPC: The body of a function call. The object is the function identifier and the assertions on the object are the function parameters.</td>
          </tr>
          <tr>
            <td align="left">101</td>
            <td align="left">
              <tt>result</tt></td>
            <td align="left">predicate</td>
            <td align="left">RPC: A result of a successful function call. The object is the returned value.</td>
          </tr>
          <tr>
            <td align="left">102</td>
            <td align="left">
              <tt>error</tt></td>
            <td align="left">predicate</td>
            <td align="left">RPC: A result of an unsuccessful function call. The object is message or other diagnostic state.</td>
          </tr>
          <tr>
            <td align="left">103</td>
            <td align="left">
              <tt>ok</tt></td>
            <td align="left">object</td>
            <td align="left">RPC: The object of a <tt>result</tt> predicate for a successful remote procedure call that has no other return value.</td>
          </tr>
          <tr>
            <td align="left">104</td>
            <td align="left">
              <tt>processing</tt></td>
            <td align="left">object</td>
            <td align="left">RPC: The object of a <tt>result</tt> predicate where a function call is accepted for processing and has not yet produced a result or error.</td>
          </tr>
        </tbody>
      </table>
    </section>
    <section anchor="existence-proofs">
      <name>Existence Proofs</name>
      <t>This section is informative.</t>
      <t>Because each element of an envelope provides a unique digest, and because changing an element in an envelope changes the digest of all elements upwards towards its root, the structure of an envelope is comparable to a <xref target="MERKLE"/>.</t>
      <t>In a Merkle Tree, all semantically significant information is carried by the tree's leaves (for example, the transactions in a block of Bitcoin transactions) while the internal nodes of the tree are nothing but digests computed from combinations of pairs of lower nodes, all the way up to the root of the tree (the "Merkle root".)</t>
      <t>In an envelope, every digest references some semantically significant content: it could reference the subject of the envelope, or one of the assertions in the envelope, or at the predicate or object of a given assertion. Of course, those elements are all envelopes themselves, and thus potentially the root of their own subtree.</t>
      <t>In a merkle tree, the minumum subset of hashes necessary to confirm that a specific leaf node (the "target") must be present is called a "Merkle proof." For envelopes, an analogous proof would be a transformation of the envelope that is entirely elided but preserves the structure necesssary to reveal the target.</t>
      <t>As an example, we produce an envelope representing a simple FOAF <xref target="FOAF"/> style graph:</t>
      <sourcecode type="sh"><![CDATA[
$ ALICE_FRIENDS=`envelope subject Alice |
    envelope assertion knows Bob |
    envelope assertion knows Carol |
    envelope assertion knows Dan`

$ envelope $ALICE_FRIENDS
"Alice" [
    "knows": "Bob"
    "knows": "Carol"
    "knows": "Dan"
]
]]></sourcecode>
      <t>We then elide the entire envelope, leaving only the root-level digest. This digest is a cryptographic commitment to the envelope's contents.</t>
      <sourcecode type="sh"><![CDATA[
$ COMMITMENT=`envelope elide $ALICE_FRIENDS`
$ envelope --tree $COMMITMENT
cd84aa96 ELIDED
]]></sourcecode>
      <t>A third party, having received this commitment, can then request proof that the envelope contains a particular assertion, called the <em>target</em>.</t>
      <sourcecode type="sh"><![CDATA[
$ REQUESTED_ASSERTION=`envelope subject assertion knows Bob`

$ envelope --tree $REQUESTED_ASSERTION
55560bdf ASSERTION
    7092d620 pred "knows"
    9a771715 obj "Bob"
]]></sourcecode>
      <t>The holder can then produce a proof, which is an elided form of the original document that contains a minimum spanning set of digests including the target.</t>
      <sourcecode type="sh"><![CDATA[
$ KNOWS_BOB_DIGEST=`envelope digest $REQUESTED_ASSERTION`

$ KNOWS_BOB_PROOF=`envelope proof create $ALICE_FRIENDS $KNOWS_BOB_DIGEST`

$ envelope --tree $KNOWS_BOB_PROOF
cd84aa96 NODE
    27840350 subj ELIDED
    55560bdf ELIDED
    71a30690 ELIDED
    907c8857 ELIDED
]]></sourcecode>
      <t>Note that the proof:</t>
      <ol spacing="normal" type="1"><li>has the same root digest as the commitment,</li>
        <li>includes the digest of the <tt>knows-Bob</tt> assertion: <tt>55560bdf</tt>,</li>
        <li>includes only the other digests necessary to calculate the digest tree from the target back to the root, without revealing any additional information about the envelope.</li>
      </ol>
      <t>Criteria 3 was met when the proof was produced. Critera 1 and 2 are checked by the command line tool when confirming the proof:</t>
      <sourcecode type="sh"><![CDATA[
$ envelope proof confirm --silent $COMMITMENT $KNOWS_BOB_PROOF $KNOWS_BOB_DIGEST && echo "Success"
Success
]]></sourcecode>
    </section>
    <section anchor="reference-implementation">
      <name>Reference Implementation</name>
      <t>This section is informative.</t>
      <t>The current reference implementation of envelope is written in Swift and is part of the Blockchain Commons Secure Components Framework <xref target="ENVELOPE-REFIMPL"/>.</t>
      <t>The envelope command line tool <xref target="ENVELOPE-CLI"/> is also written in Swift.</t>
    </section>
    <section anchor="future-proofing">
      <name>Future Proofing</name>
      <t>This section is informative.</t>
      <t>Because envelope is a specification for documents that may persist indefinitely, it is a design goal of this specification that later implementation versions are able to parse envelopes produced by earlier versions. Furthermore, later implementations should be able to compose new envelopes using older envelopes as components.</t>
      <t>The authors considered adding a version number to every envelope, but deemed this unnecessary as any code that parses later envelopes can determine what features are required from the CBOR structure alone.</t>
      <t>The general migration strategy is that the specific structure of envelopes defined in the first general release of this specification is the baseline, and later specifications may incrementally add structural features such as envelope cases, new tags, or support for new structures or algorithms, but are generally expected to maintain backward compatibility.</t>
      <t>An example of addition would be to add an additional supported method of encryption. The <tt>crypto-msg</tt> specification CDDL is a CBOR array with either three or four elements:</t>
      <sourcecode type="cddl"><![CDATA[
crypto-msg = #6.201([ ciphertext, nonce, auth, ? aad ])
ciphertext = bytes       ; encrypted using ChaCha20
aad = digest             ; Additional Authenticated Data
nonce = bytes .size 12   ; Random, generated at encryption-time
auth = bytes .size 16    ; Authentication tag created by Poly1305
]]></sourcecode>
      <t>For the sake of this example we assume the new method to be supported has all the same fields, but needs to be processed differently. In this case, the first element of the array could become an optional integer:</t>
      <sourcecode type="cddl"><![CDATA[
crypto-msg = #6.201([ ? version, ciphertext, nonce, auth, ? aad ])
version = uint           ; absent for old method, 1 for new method
]]></sourcecode>
      <t>If present, the first field specifies the later encryption method. If absent, the original encryption method is specified. For low numbered versions, the storage cost of specifying a later version is one byte, and backwards compatibility is preserved.</t>
    </section>
    <section anchor="security-considerations">
      <name>Security Considerations</name>
      <t>This section is informative unless noted otherwise.</t>
      <section anchor="structural-considerations">
        <name>Structural Considerations</name>
        <section anchor="cbor-considerations">
          <name>CBOR Considerations</name>
          <t>Generally, this document inherits the security considerations of CBOR <xref target="RFC8949"/>. Though CBOR has limited web usage, it has received strong usage in hardware, resulting in a mature specification.</t>
        </section>
      </section>
      <section anchor="cryptographic-considerations">
        <name>Cryptographic Considerations</name>
        <section anchor="inherited-considerations">
          <name>Inherited Considerations</name>
          <t>Generally, this document inherits the security considerations of the cryptographic constructs it uses such as IETF-ChaCha20-Poly1305 <xref target="RFC7539"/> and BLAKE3 <xref target="BLAKE3"/>.</t>
        </section>
        <section anchor="choice-of-cryptographic-primitives-no-set-curve">
          <name>Choice of Cryptographic Primitives (No Set Curve)</name>
          <t>Though envelope recommends the use of certain cryptographic algorithms, most are not required (with the exception of BLAKE3 usage, noted below). In particular, envelope has no required curve. Different choices will obviously result in different security considerations.</t>
        </section>
      </section>
      <section anchor="validation-requirements">
        <name>Validation Requirements</name>
        <t>Unlike HTML, envelope is intended to be conservative in both what it sends <em>and</em> what it accepts. This means that receivers of envelope-based documents should carefully validate them. Any deviation from the validation requirements of this specification <bcp14>MUST</bcp14> result in the rejection of the entire envelope. Even after validation, envelope contents should be treated with due skepticism.</t>
      </section>
      <section anchor="signature-considerations">
        <name>Signature Considerations</name>
        <t>This specification allows the signing of envelopes that are partially (or even entirely) elided. There may be use cases for this, such as when multiple users are each signing partially elided envelopes that will then be united. However, it's generally a dangerous practice. Our own tools require overrides to allow it. Other developes should take care to warn users of the dangers of signing elided envelopes.</t>
      </section>
      <section anchor="hashing">
        <name>Hashing</name>
        <section anchor="choice-of-blake3-hash-primitive">
          <name>Choice of BLAKE3 Hash Primitive</name>
          <t>Although BLAKE2 is more widely supported by IETF specifications, envelope instead makes use of BLAKE3. This is to take advantage of advances in the updated protocol: the new BLAKE3 implementation uses a Merkle Tree format that allows for streaming and for incremental updates as well as high levels of parallelism. The fact that BLAKE3 is newer should be taken into consideration, but its foundation in BLAKE2 and its support by experts such as the Zcash Foundation are considered to grant it sufficient maturity.</t>
          <t>Whereas, envelope is written to allow for the easy exchange of most of its cryptographic protocols, this is not true for BLAKE3: swapping for another hash protocol would result in incompatible envelopes. Thus, any security considerations related to BLAKE3 should be given careful attention.</t>
        </section>
        <section anchor="well-known-hashes">
          <name>Well-Known Hashes</name>
          <t>Because they are short unsigned integers, well-known values produce well-known digests. Elided envelopes may in some cases inadvertently reveal information by transmitting digests that may be correlated to known information. Envelopes can be salted by adding assertions that contain random data to perturb the digest tree, hence decorrelating it from any known values.</t>
        </section>
        <section anchor="digest-trees">
          <name>Digest Trees</name>
          <t>Existence proofs include the minimal set of digests that are necessary to calculate the digest tree from the target to the root, but may themselves leak information about the contents of the envelope due to the other digests that must be included in the spanning set. Designers of envelope-based formats should anticipate such attacks and use decorrelation mechanisms like salting where necessary.</t>
        </section>
        <section anchor="a-tree-not-a-list">
          <name>A Tree, Not a List</name>
          <t>Envelope makes use of a hash tree instead of a hash list to allow this sort of minimal revelation. This decision may also have advantages in scaling. However, there should be further investigation of the limitations of hash trees regarding scaling, particularly for the scaling of large, elided structures.</t>
          <t>There should also be careful consideration of the best practices needed for the creation of deeply nested envelopes, for the usage of subenvelopes created at different times, and for other technical details related to the use of a potentially broad hash tree, as such best practices do not currently exist.</t>
        </section>
        <section anchor="salts">
          <name>Salts</name>
          <t>Specifics for the size and usage of salt are not included in this specifications. There are also no requirements for whether salts should be revealed or can be elided. Careful attention may be required for these factors to ensure that they don't accidentally introduce vulnerabilities into usage.</t>
        </section>
        <section anchor="collisions">
          <name>Collisions</name>
          <t>Hash trees tend to make it harder to create collisions than the use of a raw hash function. If attackers manage to find a collision for a hash, they can only replace one node (and its children), so the impact is limited, especially since finding collisions higher in a hash tree grows increasingly difficult because the collision must be a concatenation of multiple hashes. This should generally reduce issues with collisions: finding collisions that fit a hash tree tends to be harder than finding regular collisions. But, the issue always should be considered.</t>
        </section>
        <section anchor="leaf-node-attacks">
          <name>Leaf-Node Attacks</name>
          <t>Envelope's hash tree  is proof against the leaf-node weakness of Bitcoin that can affect SPVs because its predicates are an unordered set, serialized in increasing lexicographic order by digest, with no possibility for duplication and thus fully deterministic ordering of the tree.</t>
          <t>See https://bitslog.com/2018/06/09/leaf-node-weakness-in-bitcoin-merkle-tree-design/ for the leaf-node attack.</t>
        </section>
        <section anchor="forgery-attacks-on-unbalanced-trees">
          <name>Forgery Attacks on Unbalanced Trees</name>
          <t>Envelopes should also be proof against forgery attacks before of their different construction, where all nodes contain both data and hashes. Nonetheless, care must still be taken with trees, especially when also using redaction, which limits visible information.</t>
          <t>See https://bitcointalk.org/?topic=102395 for the forgery attack.</t>
        </section>
      </section>
      <section anchor="elision">
        <name>Elision</name>
        <section anchor="duplication-of-claims">
          <name>Duplication of Claims</name>
          <t>Support for elision allows for the possibility of contradictory claims where one is kept hidden at any time. So, for example, an evelope could contain contradictory predictions of election results and only reveal the one that matches the actual results. As a result, revealed material should be carefully assessed for this possibility when redacted material also exists.</t>
        </section>
      </section>
      <section anchor="additional-specification-creation">
        <name>Additional Specification Creation</name>
        <t>Creators of specifications for envelope-based documents should give due consideration to security implications that are outside the scope of this specification to anticipate or avert. One example would be the number and type of assertions allowed in a particular document, and whether additional assertions (metadata) are allowed on those assertions.</t>
      </section>
    </section>
    <section anchor="iana-considerations">
      <name>IANA Considerations</name>
      <section anchor="cbor-tags">
        <name>CBOR Tags</name>
        <t>This section proposes a number of IANA allocated specific CBOR tags <xref target="IANA-CBOR-TAGS"/>.</t>
        <t>In the table below, tags directly referenced in this specification have "yes" in the "spec" field.</t>
        <t>The reference implementation <xref target="ENVELOPE-REFIMPL"/> uses tags not used in this specification, and these are marked "no" in the "spec" field.</t>
        <t>This document requests that IANA reserve the assigned tags listed below in the range 200-230 for use by envelope and associated specifications.</t>
        <table>
          <thead>
            <tr>
              <th align="left">data item</th>
              <th align="left">spec</th>
              <th align="left">semantics</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">200</td>
              <td align="left">yes</td>
              <td align="left">envelope</td>
            </tr>
            <tr>
              <td align="left">201</td>
              <td align="left">yes</td>
              <td align="left">crypto-message</td>
            </tr>
            <tr>
              <td align="left">202</td>
              <td align="left">no</td>
              <td align="left">common-identifier</td>
            </tr>
            <tr>
              <td align="left">203</td>
              <td align="left">yes</td>
              <td align="left">digest</td>
            </tr>
            <tr>
              <td align="left">204</td>
              <td align="left">no</td>
              <td align="left">symmetric-key</td>
            </tr>
            <tr>
              <td align="left">205</td>
              <td align="left">no</td>
              <td align="left">private-key-base</td>
            </tr>
            <tr>
              <td align="left">206</td>
              <td align="left">no</td>
              <td align="left">public-key-base</td>
            </tr>
            <tr>
              <td align="left">207</td>
              <td align="left">no</td>
              <td align="left">sealed-message</td>
            </tr>
            <tr>
              <td align="left">208-221</td>
              <td align="left">no</td>
              <td align="left">unassigned</td>
            </tr>
            <tr>
              <td align="left">221</td>
              <td align="left">yes</td>
              <td align="left">assertion</td>
            </tr>
            <tr>
              <td align="left">222</td>
              <td align="left">no</td>
              <td align="left">signature</td>
            </tr>
            <tr>
              <td align="left">223</td>
              <td align="left">yes</td>
              <td align="left">known-value</td>
            </tr>
            <tr>
              <td align="left">224</td>
              <td align="left">yes</td>
              <td align="left">wrapped-envelope</td>
            </tr>
            <tr>
              <td align="left">225-229</td>
              <td align="left">no</td>
              <td align="left">unassigned</td>
            </tr>
            <tr>
              <td align="left">230</td>
              <td align="left">no</td>
              <td align="left">agreement-public-key</td>
            </tr>
          </tbody>
        </table>
        <t>Points of contact:
    * Christopher Allen <eref target="mailto:christophera@blockchaincommons.com">christophera@blockchaincommons.com</eref>
    * Wolf McNally <eref target="mailto:wolf@wolfmcnally.com">wolf@wolfmcnally.com</eref></t>
      </section>
      <section anchor="media-type">
        <name>Media Type</name>
        <t>The proposed media type <xref target="RFC6838"/> for envelope is <tt>application/envelope+cbor</tt>.</t>
        <ul spacing="normal">
          <li>Type name: application</li>
          <li>Subtype name: envelope+cbor</li>
          <li>Required parameters: n/a</li>
          <li>Optional parameters: n/a</li>
          <li>Encoding considerations: binary</li>
          <li>Security considerations: See the previous section of this document</li>
          <li>Interoperability considerations: n/a</li>
          <li>Published specification: This document</li>
          <li>Applications that use this media type:  None yet, but it is expected that this format will be deployed in protocols and applications.</li>
          <li>
            <t>Additional information:
            </t>
            <ul spacing="normal">
              <li>Magic number(s): n/a</li>
              <li>File extension(s): .envelope</li>
              <li>Macintosh file type code(s): n/a</li>
            </ul>
          </li>
          <li>
            <t>Person &amp; email address to contact for further information:
            </t>
            <ul spacing="normal">
              <li>Christopher Allen <eref target="mailto:christophera@blockchaincommons.com">christophera@blockchaincommons.com</eref></li>
              <li>Wolf McNally <eref target="mailto:wolf@wolfmcnally.com">wolf@wolfmcnally.com</eref></li>
            </ul>
          </li>
          <li>Intended usage: COMMON</li>
          <li>Restrictions on usage: none</li>
          <li>
            <t>Author:
            </t>
            <ul spacing="normal">
              <li>Wolf McNally <eref target="mailto:wolf@wolfmcnally.com">wolf@wolfmcnally.com</eref></li>
            </ul>
          </li>
          <li>
            <t>Change controller:
            </t>
            <ul spacing="normal">
              <li>The IESG <eref target="mailto:iesg@ietf.org">iesg@ietf.org</eref></li>
            </ul>
          </li>
        </ul>
      </section>
    </section>
  </middle>
  <back>
    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <reference anchor="RFC8949">
          <front>
            <title>Concise Binary Object Representation (CBOR)</title>
            <author fullname="C. Bormann" initials="C." surname="Bormann">
              <organization/>
            </author>
            <author fullname="P. Hoffman" initials="P." surname="Hoffman">
              <organization/>
            </author>
            <date month="December" year="2020"/>
            <abstract>
              <t>The Concise Binary Object Representation (CBOR) is a data format whose design goals include the possibility of extremely small code size, fairly small message size, and extensibility without the need for version negotiation. These design goals make it different from earlier binary serializations such as ASN.1 and MessagePack.</t>
              <t>This document obsoletes RFC 7049, providing editorial improvements, new details, and errata fixes while keeping full compatibility with the interchange format of RFC 7049.  It does not create a new version of the format.</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="94"/>
          <seriesInfo name="RFC" value="8949"/>
          <seriesInfo name="DOI" value="10.17487/RFC8949"/>
        </reference>
        <reference anchor="RFC8610">
          <front>
            <title>Concise Data Definition Language (CDDL): A Notational Convention to Express Concise Binary Object Representation (CBOR) and JSON Data Structures</title>
            <author fullname="H. Birkholz" initials="H." surname="Birkholz">
              <organization/>
            </author>
            <author fullname="C. Vigano" initials="C." surname="Vigano">
              <organization/>
            </author>
            <author fullname="C. Bormann" initials="C." surname="Bormann">
              <organization/>
            </author>
            <date month="June" year="2019"/>
            <abstract>
              <t>This document proposes a notational convention to express Concise Binary Object Representation (CBOR) data structures (RFC 7049).  Its main goal is to provide an easy and unambiguous way to express structures for protocol messages and data formats that use CBOR or JSON.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8610"/>
          <seriesInfo name="DOI" value="10.17487/RFC8610"/>
        </reference>
        <reference anchor="RFC7539">
          <front>
            <title>ChaCha20 and Poly1305 for IETF Protocols</title>
            <author fullname="Y. Nir" initials="Y." surname="Nir">
              <organization/>
            </author>
            <author fullname="A. Langley" initials="A." surname="Langley">
              <organization/>
            </author>
            <date month="May" year="2015"/>
            <abstract>
              <t>This document defines the ChaCha20 stream cipher as well as the use of the Poly1305 authenticator, both as stand-alone algorithms and as a "combined mode", or Authenticated Encryption with Associated Data (AEAD) algorithm.</t>
              <t>This document does not introduce any new crypto, but is meant to serve as a stable reference and an implementation guide.  It is a product of the Crypto Forum Research Group (CFRG).</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7539"/>
          <seriesInfo name="DOI" value="10.17487/RFC7539"/>
        </reference>
        <reference anchor="RFC6838">
          <front>
            <title>Media Type Specifications and Registration Procedures</title>
            <author fullname="N. Freed" initials="N." surname="Freed">
              <organization/>
            </author>
            <author fullname="J. Klensin" initials="J." surname="Klensin">
              <organization/>
            </author>
            <author fullname="T. Hansen" initials="T." surname="Hansen">
              <organization/>
            </author>
            <date month="January" year="2013"/>
            <abstract>
              <t>This document defines procedures for the specification and registration of media types for use in HTTP, MIME, and other Internet protocols.  This memo documents an Internet Best Current Practice.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="13"/>
          <seriesInfo name="RFC" value="6838"/>
          <seriesInfo name="DOI" value="10.17487/RFC6838"/>
        </reference>
        <reference anchor="IANA-CBOR-TAGS" target="https://www.iana.org/assignments/cbor-tags/cbor-tags.xhtml">
          <front>
            <title>IANA, Concise Binary Object Representation (CBOR) Tags</title>
            <author>
              <organization/>
            </author>
            <date>n.d.</date>
          </front>
        </reference>
        <reference anchor="BLAKE3" target="https://blake3.io">
          <front>
            <title>BLAKE3 Cryptographic Hash Function</title>
            <author>
              <organization/>
            </author>
            <date>n.d.</date>
          </front>
        </reference>
        <reference anchor="CRYPTO-MSG" target="https://github.com/BlockchainCommons/Research/blob/master/papers/bcr-2022-001-secure-message.md">
          <front>
            <title>UR Type Definition for Secure Messages</title>
            <author>
              <organization/>
            </author>
            <date>n.d.</date>
          </front>
        </reference>
        <reference anchor="ENVELOPE-REFIMPL" target="https://github.com/BlockchainCommons/BCSwiftSecureComponents">
          <front>
            <title>Envelope Reference Implementation, part of the Blockchain Commons Secure Components Framework</title>
            <author>
              <organization/>
            </author>
            <date>n.d.</date>
          </front>
        </reference>
        <reference anchor="ENVELOPE-CLI" target="https://github.com/BlockchainCommons/envelope-cli-swift">
          <front>
            <title>Envelope Command Line Tool</title>
            <author>
              <organization/>
            </author>
            <date>n.d.</date>
          </front>
        </reference>
        <reference anchor="RFC2119">
          <front>
            <title>Key words for use in RFCs to Indicate Requirement Levels</title>
            <author fullname="S. Bradner" initials="S." surname="Bradner">
              <organization/>
            </author>
            <date month="March" year="1997"/>
            <abstract>
              <t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="2119"/>
          <seriesInfo name="DOI" value="10.17487/RFC2119"/>
        </reference>
        <reference anchor="RFC8174">
          <front>
            <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
            <author fullname="B. Leiba" initials="B." surname="Leiba">
              <organization/>
            </author>
            <date month="May" year="2017"/>
            <abstract>
              <t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="8174"/>
          <seriesInfo name="DOI" value="10.17487/RFC8174"/>
        </reference>
      </references>
      <references>
        <name>Informative References</name>
        <reference anchor="MERKLE" target="https://en.wikipedia.org/wiki/Merkle_tree">
          <front>
            <title>Merkle Tree</title>
            <author>
              <organization/>
            </author>
            <date>n.d.</date>
          </front>
        </reference>
        <reference anchor="TRIPLE" target="https://en.wikipedia.org/wiki/Semantic_triple">
          <front>
            <title>Semantic Triple</title>
            <author>
              <organization/>
            </author>
            <date>n.d.</date>
          </front>
        </reference>
        <reference anchor="RFC8259">
          <front>
            <title>The JavaScript Object Notation (JSON) Data Interchange Format</title>
            <author fullname="T. Bray" initials="T." role="editor" surname="Bray">
              <organization/>
            </author>
            <date month="December" year="2017"/>
            <abstract>
              <t>JavaScript Object Notation (JSON) is a lightweight, text-based, language-independent data interchange format.  It was derived from the ECMAScript Programming Language Standard.  JSON defines a small set of formatting rules for the portable representation of structured data.</t>
              <t>This document removes inconsistencies with other specifications of JSON, repairs specification errors, and offers experience-based interoperability guidance.</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="90"/>
          <seriesInfo name="RFC" value="8259"/>
          <seriesInfo name="DOI" value="10.17487/RFC8259"/>
        </reference>
        <reference anchor="RFC6973">
          <front>
            <title>Privacy Considerations for Internet Protocols</title>
            <author fullname="A. Cooper" initials="A." surname="Cooper">
              <organization/>
            </author>
            <author fullname="H. Tschofenig" initials="H." surname="Tschofenig">
              <organization/>
            </author>
            <author fullname="B. Aboba" initials="B." surname="Aboba">
              <organization/>
            </author>
            <author fullname="J. Peterson" initials="J." surname="Peterson">
              <organization/>
            </author>
            <author fullname="J. Morris" initials="J." surname="Morris">
              <organization/>
            </author>
            <author fullname="M. Hansen" initials="M." surname="Hansen">
              <organization/>
            </author>
            <author fullname="R. Smith" initials="R." surname="Smith">
              <organization/>
            </author>
            <date month="July" year="2013"/>
            <abstract>
              <t>This document offers guidance for developing privacy considerations for inclusion in protocol specifications.  It aims to make designers, implementers, and users of Internet protocols aware of privacy-related design choices.  It suggests that whether any individual RFC warrants a specific privacy considerations section will depend on the document's content.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6973"/>
          <seriesInfo name="DOI" value="10.17487/RFC6973"/>
        </reference>
        <reference anchor="RFC8280">
          <front>
            <title>Research into Human Rights Protocol Considerations</title>
            <author fullname="N. ten Oever" initials="N." surname="ten Oever">
              <organization/>
            </author>
            <author fullname="C. Cath" initials="C." surname="Cath">
              <organization/>
            </author>
            <date month="October" year="2017"/>
            <abstract>
              <t>This document aims to propose guidelines for human rights considerations, similar to the work done on the guidelines for privacy considerations (RFC 6973).  The other parts of this document explain the background of the guidelines and how they were developed.</t>
              <t>This document is the first milestone in a longer-term research effort.  It has been reviewed by the Human Rights Protocol Considerations (HRPC) Research Group and also by individuals from outside the research group.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8280"/>
          <seriesInfo name="DOI" value="10.17487/RFC8280"/>
        </reference>
        <reference anchor="JSONLD" target="https://json-ld.org/spec/latest/">
          <front>
            <title>JSON-LD, Latest Specifications</title>
            <author>
              <organization/>
            </author>
            <date>n.d.</date>
          </front>
        </reference>
        <reference anchor="PROTOBUF" target="https://developers.google.com/protocol-buffers/">
          <front>
            <title>Protocol Buffers</title>
            <author>
              <organization/>
            </author>
            <date>n.d.</date>
          </front>
        </reference>
        <reference anchor="MERMAID" target="https://mermaid-js.github.io/mermaid/#/">
          <front>
            <title>Mermaid.js</title>
            <author>
              <organization/>
            </author>
            <date>n.d.</date>
          </front>
        </reference>
        <reference anchor="FOAF" target="https://en.wikipedia.org/wiki/FOAF">
          <front>
            <title>Friend of a Friend (FOAF)</title>
            <author>
              <organization/>
            </author>
            <date>n.d.</date>
          </front>
        </reference>
        <reference anchor="SSKR" target="https://github.com/BlockchainCommons/Research/blob/master/papers/bcr-2020-011-sskr.md">
          <front>
            <title>Sharded Secret Key Recovery (SSKR)</title>
            <author>
              <organization/>
            </author>
            <date>n.d.</date>
          </front>
        </reference>
        <reference anchor="OWL" target="https://www.w3.org/OWL/">
          <front>
            <title>Web Ontology Language (OWL)</title>
            <author>
              <organization/>
            </author>
            <date>n.d.</date>
          </front>
        </reference>
        <reference anchor="ISO639" target="https://en.wikipedia.org/wiki/ISO_639">
          <front>
            <title>ISO 639 - Standard for representation of names for language and language groups</title>
            <author>
              <organization/>
            </author>
            <date>n.d.</date>
          </front>
        </reference>
      </references>
    </references>
    <section numbered="false" anchor="acknowledgments">
      <name>Acknowledgments</name>
      <t>TODO acknowledge.</t>
    </section>
  </back>
  <!-- ##markdown-source:
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
fxR+Da9FPRn6Ok2ua7M5DvpLdARcHPvntLe2d0HMj96mWdLBpUR9O2Z5dP0R
Y1pSpkrNbmgebWBG8y/NbxvNFg415cTCvEeb+87jKNvDgYUInE2BSXO26xDP
PjSzY6LO9T17qfEbD5cpx4dHG5nRAC0uYNNLLBh5vW0vIGFQlHL1SXsRG4k0
9zWdwgzCIn95qxfURcjrqYROXsLqO+WKyRofsAcYXuHYrBDbZGOzbrPpTWiT
roQtu4HK8QeWy71Vrv0eyL4vXs6+WY40fp3rYvvh34eelEIAhCYTy1A2qbJy
vWY8LYnnn5j5GS9+0Oty+/xNhzjUt6JZUy3p4rvXV8VFvcze5axLPmFeL3Iu
bgRhvxUuwmWWFrzKA7NKvBIkXPDPqbp+AEqvcopmWwnIKg+QsSnaKVXzTQFa
uaO7YefZZiHUx10LF+h1ZVF4FNXa0c7momzXKq+yF6l++KIRm4VX7dyUfpRm
lzJhzxEXMs/r7ROizNuiHNTYhAzZlyFNjf3rnUOapu4fPnDbd6AGKtZum4JT
Bx9iUBs1++HEscGm3rKAgWWl5crg/ufgvwHytyj9yxXLKASvzDM0sKOb619l
HtNPzVayNweK2zXZT+70l2D2YmFZWdDI8CE1r+7ju9N5Hr+lLmVUaZVr1zut
1Wt3hhOsiulGlsqWKn0JoDJg2FyK6NOCxobG1P2CgCyfCtQMU+GacijSBV20
Ni0otioP9lo/skamc0NKXZ4bjabdc1+8OubOF8a2Uq6WF47PZqxJBGf+Zx/w
jtL2tQ/aknqJuqZSh30ZLYEFdnswp9ft8YKBaFf++W1Z8FHED/GCgRdhwzG0
nB9ce6HhPJEZkl5oZu4L18ESINf3giqYmaqqf+TkRixj42wym7zaPSV2gzZr
GfBa8rf+oeFHMhb9bo/NJcsoBzm3atHy3Rq3I5Et2pvlsjqGUwiloYg1fLdE
WX79BSuTEpoh0ChVKcaGe1J70s1FGMZLrKK1tkXmEqIMPpKCi7jgejEPFxvb
k3L/ivraPeQdMq2Cg2brNYeC15JJ2JnfW9VciMVOxze1Kja1Nr/0yEbvTMrB
MoUxV0vM7EPZzj/RxMW2e61aQtOmz4Mr45i698pvLE85q0Hbee5XZvIzKUuN
Co6i4ULrDhq7Ye/o1JVsRGb4LVZoBvOqjB5R3Uk2l4SHYY1aFbuKoY73Pkmr
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
AAA=

-->

</rfc>
